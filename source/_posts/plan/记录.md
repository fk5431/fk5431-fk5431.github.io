---
title: 记录
date: 2020-02-20 11:32
comments: false
tags: 
- java
- 记录
categories: 
- java
- 记录
keywords:
- 记录
---

### java

- switch 之前可以用整数 或者 枚举常量来表示，byte short char 都可以隐式换为int，1.7开始支持字符串，case 时必须为字符串常量，处理方式用的字符串的hashcode，编译完之后仍是用的int去判断的

- 静态变量实例变量：实例变量是某个类的属性，必须创建了实例对象 变量才会分配空间，才能使用；静态变量不属于实例对象而属于类，只要程序加载了类的字节码，静态变量就会被分配空间就可以使用了。

- 内部类

- sleep wait：sleep是Thread的方法，wait是Object的方法。sleep会让当前线程让出CPU，CPU去执行其他方法，在sleep时间之后在回来执行，如果当前线程进入了同步锁，也不会释放锁。wait是指进入同步锁的线程放弃自己持有的同步锁，让其他等待线程去获取锁，只有其他线程调用了notify之后，此线程才可以去争抢同步锁。

- 线程状态：就绪、运行、阻塞、挂起、结束。（wait必须在synchronized中调用） 调用线程的start进入就绪，线程调度系统将就绪状态的线程变为运行状态，遇到synchronized可能会阻塞，获取锁之后 阻塞变为运行，调用wait之后变为挂起，线程相关代码执行完之后变为结束。

- hashmap为什么用红黑树而不用其他树：AVL是完全平衡二叉树，查找删除修改的时间复杂度都是 O(lgn),ConcurrentHashMap中是加锁的，本质是读写锁，如果写冲突就会等待，红黑树的插入更快。红黑树允许局部的很少不平衡，avl在调整平衡代价比较。

- hashmap为什么8的之后树化：红黑树的平均查找复杂度是O(lgn)，链表的平均 是 n/2，当长度为8是，红黑树的查找时间是3而链表是4，这样才有必要转化为树。小于6转化为链表，中间有个差值7，避免了频繁的树和链表相互转化。

- 基本类型和包装类型的区别：包装类型是一个对象，可以为空，而基本类型会有一个默认值；基本类型更高效，基本类型在栈中，包装类型存储在堆中，占用更多的内存空间；两个包装类可以值相等，对象不相等。对于自动拆箱和装箱，对于编译之后的文件（已Integer来说），装箱相当于调用了Integer.valueOf，拆箱调用了Integer.intValue。

