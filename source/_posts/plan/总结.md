---
title: 
date: 2020-03-24 14:40
comments: false
tags: 
- java
- 总结
categories: 
- java
- 总结
keywords:
- 总结
---

#### 个人介绍

我叫冯凯，我现在在闪银奇异工作，我们公司主要业务是金融助贷业务，我们部门主要负责对接放款的资金方，我最近负责的项目内容有 合同系统、签章平台、短信平台 和 平台系统相关内容。

#### 项目经验

平台系统（后台）没什么说的。

订单流程 状态机
分布式 最终消息一致性。
- 系统的核心流程在于消息，使用消息的AtLeastOnce机制来保证数据的最终一致性
    - 最后发送ACK
    - 幂等
- 数据变更消息发送问题
    - 代码中使用事务消息组件，发送消息（在Transaction中发送消息，成功就一定能发送，rollback一定发不出去）
        - 好处，简单易用
        - 缺点，需要在业务逻辑中手动加入各种发消息的逻辑，有漏的可能性
    - 接收Canal的消息，处理成我们自己的消息，然后发送的队列
        - 好处，很难漏掉消息，同时对直接修数据库也可以发送消息
        - 缺点，需要再额外启动线程来做处理，比较麻烦
订单 提单 查单 开户 上传文件 协议支付
一套action结构，初始化线程池、从Apollo读取配置，将资方Id,资方产品Id,状态 当key注册缓存，然后状态机流转，对应处理对应的action

合同系统是整个助贷业务的合规基础，合同系统从0到1，切入到助贷业务环节中，尽可能的从借贷业务中剥离开来。合同系统的难点主要在于从0-1，从业务上讲，合同不一定影响放款流程，但是对于监管抽查、客诉、资方、保险等情况是需要合规证据的，所以从业务上来讲保证合同的不缺失、不存储错类型是一个难点。解决方案 配置化规则+合同模板的基础 去检查放款订单的合同，对于缺失+多余的需要人工check，完善规则或者模板。
复杂性 在于：合同模块开始是不存在的，之前耦合在项目中的资方模块 有很多不在管理中，迁移改造没有做，对于新上资方 对接人员的处理不一定完善，合同在业务上地位不是很高，属于事后才会关心，业务上以放款成功 放款时效为主。


签章平台是对整个公司内部签章提供服务的系统，业务不复杂，主要对接第三方系统，目前有即享和法大大。并发每秒也就50.项目难点在于高峰时期出现过几次服务反应很慢，重启解决。事后寻找原因（业务上出现大量的无效请求），某个时间段请求量过大，导致服务处理不过来，Eden区内存分配满，担保分配到老年代，导致JVM频繁回收（FullGC）PSYoungGen 新生代（1.3G），ParOldGen 老年代 （2.7G)。增加限流，过滤无效请求，增大Eden大小。                    

锁超时 和 死锁的情况 
项目情况，查询 不存在，插入 然后去签章 上传oss ，更新，这个过程会出现锁超时，上传oss时间过长 911s，导致请求端认为超时，然后重试，重试就会检测到行锁，然后等待，最后超时.
解决，原本项目中oss工具类是公用的，发现构造OSSClient 没有去限制超时时间和重试次数，就可能会发生上传时间过长，增加连接超时的配置。
还有少量的死锁的情况，也是由于签章时间比较长，导致超时，同一个唯一索引的的请求同时来了多个（不知道为什么），然后签章报错回滚，导致死锁。
因为insert后会增加X record lock，有唯一索引冲突，会加排他意向锁 X insert intention lock，但是唯一主键重复会转换为S record lock。第一个回滚后，后面两个请求都要占用X record lock，X S锁互斥，都得等待对方释放S 锁

在一个事物中，先查询这个记录是否存在，然后新增和更新，瞬间出现高并发情况，由于间隙锁导致了锁超时和死锁的情况。



短信平台 是给公司内部提供具体发送短信，邮件，智能外呼机器人、push的服务，主要采用异步的方式进行交互，根据不同业务属性（验证码短信、营销短信、行业短信等）进行资源分配和隔离。处理线上问题，解决发送速度问题，AWS邮件发件过慢，由于业务和短信平台公用一个账号，AWS对于接口，每秒速率，日限额均有限制，单点服务，单线程处理，赛托外呼 等。
池化技术，使用java延迟队列(DelayQueue)，设定延迟时间，每个node是一个延迟任务，达到时间会 进行批量处理。
流量控制 sentinel [ˈsentɪnl]
    - 保护同步请求
    - 慢调用降级
对比 \ 线程池资源隔离 过多线程池会影响性能，上下文切换的代价比较大。Hystrix 可以针对不同资源线程池的排队、超时情况分别进行处理，但这其实是超时熔断和流量控制要解决的问题，如果组件具备了超时熔断和流量控制的能力，线程池隔离就显得没有那么必要了。
Sentinel 可以通过并发线程数模式的流量控制来提供信号量隔离的功能。Hystrix信号量隔离无法实现慢调用降级。
@SentinelResource
流量控制 单机集群qps,可以等待、失败
对流量进行管控的时候是通过责任链的模式来处理的

服务CPU100% 接口无响应， 先查top 进程，在-Hp 查线程，然后jstack dump，jmap 占用内存对象，


#### 基础知识

1. java集合知道哪些？<br/>
    - List:ArrayList, LinkedList, Vector
        - ArrayList 数组，扩容变成以前的1.5倍
        - LinkedList 链表
        - Vector 数组，线程安全，扩容变成以前的2倍
    - set:HashSet, LinkedHashSet, TreeSet
        - HashSet 去重，可有一个null，继承HashMap实现
        - LinkedHashSet 有序的，默认是插入顺序，继承于LinkedHashMap实现
        - TreeSet 有序，Comparator 元素比较大小的顺序，继承于TreeMap实现
    - Map:HashMap, LinkedHashMap, TreeMap
        - HashMap hash表，查找快，数组+桶
        - LinkedHashMap 有序，插入顺序，内部node 在维护成一个双向链表
        - TreeMap 有序，Comparator 元素比较大小顺序，红黑树底层实现

2. HashMap
    HashMap使用数组和桶进行存储，当hash中的元素超过数组大小*负载因子的时候就会进行扩容。hashmap为什么用红黑树而不用其他树：AVL是完全平衡二叉树，查找删除修改的时间复杂度都是 O(lgn),ConcurrentHashMap中是加锁的，本质是读写锁，如果写冲突就会等待，红黑树的插入更快。红黑树允许局部的很少不平衡，avl在调整平衡代价比较高。hashmap为什么8的之后树化：红黑树的平均查找复杂度是O(lgn)，链表的平均 是 n/2，当长度为8是，红黑树的查找时间是3而链表是4，这样才有必要转化为树。小于6转化为链表，中间有个差值7，避免了频繁的树和链表相互转化

3. String为什么是final
    1 为了实现字符串池 2 为了线程安全，同一个字符串可被多个线程共享 3 String是final可以创建后保证hashcode不变

4. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么
    快速失败，快速失败为集合类在遍历的过程不允许被修改，如果mod修改次数发生了变化就会抛出异常；安全失败是JUC下集合类，在遍历的时候会先复制出来一份然后进行遍历。
    
5. synchronized 的实现原理以及锁优化
    - synchronized是jvm实现的一种互斥同步锁，同时也是支持可重入的，synchronized修饰代码块的时候在编译后，会在代码块前后出现monitorentry和monitorexit两个字节码指令，当虚拟机执行到monitorentry的时候，会尝试去获取对象的锁，如果没有被锁定或已持有锁，就吧锁的计数器+1；当执行到monitorexit时候会吧锁计数器-1，如果锁的计数器是0就代表锁被释放。如果修饰在方法上 不会生成这两个指令，会在方法区中增加ACC_SYNCHRONIZED标识，进入方法时会去检测有没有这个标识，有的话会去尝试获取锁。
    - java6之前，monitor的实现完全依赖于底层操作系统的互斥锁来实现，java中的线程和操作系统中的线程有映射关系，如果要将一个线程唤醒或者阻塞都需要操作系统协助，需要从用户态转换为内核态，转换代价比较昂贵，因此对synchronized做了很多优化。
        - 自旋锁：在线程阻塞之前让线程自旋一定时间，可能在这个时间段是锁就被释放了，就不需要切换到内核态。自适应自旋锁：会动态的根据实际情况改变自旋的时间。
        - 偏向锁：当没有竞争时会默认使用偏向锁，JVM利用cas在对象的mark word上设置线程ID，表示这个对象偏向于这个锁，如果另一个线程试图锁定被偏向的对象就是撤掉偏向锁，转换为轻量级锁。
        - 轻量级锁：轻量级锁依赖CAS操作mark word来试图获取锁，如果获取成功则使用轻量级锁，如果失败则膨胀为重量级锁。
    > CAS具有原子性，原子性有CPU硬件指令实现保证，使用JNI调用Native方法调用由C++编写的硬件级别指令，JDK中提供了Unsafe类执行这些操作。

6. synchronized 锁是什么
    锁本质上是monitorentry和monitorexitz字节码指令的一个Reference类型的参数，如果指明了对象则加锁的就是该对象；如果修改非静态方法，表示此方法对应的对象是锁对象；如果修饰的是静态方法，表明此方法对应的类对象是锁对象。当一个对象被锁住的时候，对象里使用synchronized的方法都会被锁住。
    
7. 乐观锁的不足
    - 乐观锁只能保证一个共享变量的原子操作。如果有多个变量要实现原子性，就满足不了。
    - 长时间自旋会导致CPU的开销变的很大。
    - ABA问题，引入版本号

8. ReentrantLock 和 synchronized 有什么不同
    synchronized是通过在对象的mark word上增加标记来实现的，是jvm原生实现的。ReentrantLock是通过一个volatile修饰的int的state，保证每个线程都能对该state可见和修改，就是AQS的一套。ReentrantLock可实现等待中断，带超时的获取锁尝试，可判断是否有线程等待获取锁，可响应中断，可实现公平锁

9. AQS是什么
    - AQS是一个构建锁和同步器的框架。内部定义了一个volatile int state变量表示同步状态，当一个线程调用lock方法时，state为0表明没有线程占用这个资源，可以获得锁并将state设置为1；如果state为1，说明有线程占用了共享资源，其他线程必须进同步队列等待。
    - AQS通过内部Node类来实现一个双向链表的同步结构，来完成线程获取锁的排队现象。Node类是对访问同步代码的线程进行了封装，包含了线程本身和状态waitStatus。每个Node关联其prev节点和next节点，方便线程释放锁的时候唤醒下一个等待线程。Node分为共享模式和独占模式，共享模式允许多个线程占用同一资源（如：信号量），独占模式只能有一个线程占用，其他线程必须等待。
    - AQS通过内部类ConditionObject构建等待队列，Condition调用await后，线程会进入等待队列，调用signal后会从等待队列进入阻塞队列。
    
10. 还了解JUC下的什么类
    - CountDownLatch、 CyclicBarrier、 Semaphore。
    - ConcurrentHashMap、ConcunrrentSkipListMap（有序的）、CopyOnWriteArrayList线程安全的动态数组
    - ArrayBlockingQueue、 SynchorousQueue、PriorityBlockingQueue 并发队列
    - Executor 线程池
    
11. 谈谈ReadWriteLock和StampedLock
    - ReadWriteLock：多个读操作不需要互斥，如果读锁试图获取锁，此时写锁被其他线程获取，读锁将无法获取，阻塞等待写锁操作完成。当并发读多，并发写少的时候性能会比ReentrantLock和synchronized性能要好。但是大量的读线程也可能导致写线程饥饿。
    - StampedLock：相当于读写锁的优化版本，不仅提供了悲观读的方式，还提供了乐观读的方式，可以支持在读的过程中允许写锁后入，但是要在乐观读中增加判断。
    
12. 谈谈线程池
    - 线程池中的线程被包装为了Worker，是基于AQS实现的，存在方HashSet Worker workers的成员变量中，需要执行的任务存放在阻塞队列中，从BlockingQueue中不断取出任务放入worker执行。
    - 线程池常用的参数有 核心线程数、最大线程数、超时时间、时间单位、阻塞队列，线程工厂，拒绝策略。
    - 线程池开始时不启动worker，当有请求时才会创建worker，如果运行的线程数小于corePoolSize，则直接创建线程执行任务，如果大于则加入阻塞队列，如果阻塞队列满了没超过最大线程数，则创建新的线程，如果达大最大线程数则执行拒绝策略。
    
13. java内存模型
    - java内存模型定义了各个变量的访问规则，即虚拟机将变量存储和从内存中取出的底层细节，线程间变量值的传递需要通过主存。

14. 谈谈volatile
    - 保证不同线程对volatile修饰变量的可见性，禁止指令重排序。
    - 通过插入特定的内存屏障来禁止指令重排。
    - volatile修饰的变量在编译后会产生lock前缀的指令，lock前缀的指令会将当前CPU缓存行的数据写回到主存，会使其他CPU缓存行的该数据失效。缓存一致性协议，每个CPU会去嗅探总线上传播的数据来判断自己缓存的数据是否过期，如果数据的内存地址被修改过，则吧当前数据的缓存行设置为无效，用到的时候会去主存中取。

15. ThreadLocal怎么解决并发安全的问题， 使用过程中需要注意什么
    - ThreadLocal为每个线程维护了一个变量的副本，吧共享数据的范围限制在一个线程内，ThreadLocal内有一个map存储变量的副本。
    - 使用ThreadLocal要注意remove，ThreadLocal基于内部的ThreadLocalMap实现，这个map的key是一个弱引用，但是key被回收后value不会被回收，所以当变量不在使用时要注意remove

16. Thread中stop和suspend为什么不建议使用
    - stop是不安全的，它会解除线程获取的锁定，其他线程在这时候进行检查和修改可能会出现难以定位的问题。
    - suspend方法容易发生死锁，调用此方法目标线程会停下来，但是不会释放持有的锁。

17 sleep和wait有什么区别
    - sleep是Thread的方法，让线程睡眠某个时间，不会释放此时持有的锁。
    - wait指在一个同步锁内，释放自己的锁让其他线程先执行，只有其他线程调用的notify方法，会通知此线程可以去竞争锁，但不一定会马上获取到锁。
    
18. 线程有几种状态
    新建、就绪、运行、挂起、死亡

19. 现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执行？
    join方法，三个线程，T1.start() T1.join() T2.start() T2.join T3.start
    
20. 用 Java 实现阻塞队列
    通过wait和notify来实现，放元素，如果满了则wait，否则添加然后notify；取元素，如果没有则wait，否则取出然后notify返回

21. mysql InnoDB中的事务隔离级别
    - read uncommitted：读未提交
    - read committed：读已提交
    - repeatable read：可重读
    - serializable ：串行事物

22. mysql text和blob有什么区别
    区别是blob在排序和比较时候区分大小写，而text在比较和排序时不区分大小写

23. 数据库的三范式
    - 第一范式：数据库表的每一个字段都是不可分割的
    - 第二范式：数据库的非主属性只依赖于主键
    - 第三范式：不存在非主属性对关键字的传递函数依赖

24. mysql有哪几种锁
    - MyISAM支持表锁，InnoDB支持行锁和表锁，默认是行锁。
    - 表锁开销小，加锁快，不会出现死锁。锁的颗粒度大，锁冲突的概率高，并发量最小。
    - 行级锁，开销大，加锁慢，会出现死锁。发生锁冲突的概率下，并发量大。

25. mysql数据优化
    - 优化数据类型
        - 避免使用NULL值，NULL值需要特殊处理，大多数时候应该使用NOT NULL，或使用一个特殊值0，-1等作为默认值
        - 使用更小的字段，mysql是从磁盘上读取数据缓存到内存，使用CPU的周期和磁盘IO读取，越小的数据占用空间越少
    - 小心字符集转换
    - 优化子查询 子查询mysql查询优化引擎不是总是有效，可以考虑转换为连接查询
    - 优化 union ，union不会出现重复数据，并会对数据进行排序，比较浪费资源，可以用union all 替代，如果不存在重复数据

26. 知道哪些存储引擎
    - MyISAM：不支持行锁、事务、外键，执行读取速度很快，不占用大量资源和内存
    - InnoDB：InnoDB底层存储结构为B+树，B树的每个节点对应innodb的一个page，page大小是固定的，一般设为16k。其中非叶子节点只有键值，叶子节点包含完整数据。
    - Memory：数据是放在内存中的并默认使用HASH索引，因此访问速度很快。
    
27. MongoDB了解么
    - 在MongoDB中每一条记录都是一个Document。特点是高性能、易部署、易使用，存储数据方便。面向集合存储，易存储对象类型数据；支持动态查询；支持完全索引；使用高效的二进制数据存储；文件存储格式是BSON。
    - 性能很高，适合作为持久化缓存层；适合存储大尺寸，低价值的数据
    
28. 类加载过程知道么
    - 分为7个过程，加载、验证、准备、解析、初始化、使用、卸载
    - 加载：根据这个类的全限定名获取到二进制流，在内存中生成class对象，作为该类的数据访问入口。
    - 验证：保证class文件中的信息不会危害到虚拟机。文件格式验证、元数据验证、字节码验证、符号引用验证
    - 准备：为类的静态变量分配内存并初始化为默认值
    - 解析：完成符号引用到直接引用的过程
    - 初始化：执行类中定义的java代码

29. jvm加载class文件的原理
    - jvm是一种动态性的解释语言，class只有被加载到jvm才能运行。当运行指定程序时，jvm会吧.class文件按需求和一定的规则加载进jvm，这个过程是类加载器完成的（类加载器的本质就是吧类文件从硬盘读到内存）。
    - 类加载的方式分为隐式加载和显式加载，隐式加载是new的方式创建对象，会隐式调用类的加载器吧类加载进来，显式加载是通过class.forName方法

30. 如何判断一个对象是否存活
    - 引用计数法：每个对象设置一个引用计数器，有引用就加一。存在循环引用的问题
    - 可达性算法：从一个GCRoots 对象往下搜索，如果一个对象没有被任何一个GC roots引用链引用，则不可达。GC roots对象：虚拟机栈中引用的对象、方法区类静态属性引用对象、方法区常量池引用的对象、本地JNI引用的对象
    - 如果被标记为不可达。会去筛选是否有必要执行finalize方法。如果有必要执行会放入一个F-Queue队列中等待执行，虚拟机会启动一个Finalize线程执行，这个线程是低优先级的，而且不保证会执行完

31. 简单说说java内存分配和内存回收策略。MinorGC 和 FullGC
    - 对象优先在堆的Eden区分配
    - 大对象直接进老年代
    - 长期存活的对象将进入老年代
    - 当Eden区没有内存可以进行分配对象时，会进行一次MinorGC，Eden区对象生命周期短，发生GC频率高，GC速度快；FullGC发生在老年代

32. 垃圾收集的方法有哪些
    - 标记-清除：效率低，会产生大量的内存碎片
    - 复制算法：会浪费一块内存区域
    - 标记-整理
    - 分代收集：新生代采用复制算法，老年代采用标记-整理

33. 类加载器双亲委派机制
    - 当一个类收到类加载请求，不会自己直接去加载，而且委托给父类类加载器去加载，如果父类不能加载，在通过子类加载。

34. safepoint是什么
    - GC的时候要等到所有线程都到达safepoint才能进行GC
        - 循环的末尾
        - 方法返回前
        - 调用方法的call后
        - 抛出异常的位置

35. Linux中内核态和用户态是什么意思
    - 在Linux机器上，CPU要么处于被信任的内核模式占用，要么被受限制的用户模式占用。
    - 内核态可以无限制的访问所有处理器指令集和全部内存和IO空间。
    - 用户态必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。

36. 用户进程间通信的方式有几种
    - 管道：可用于具有亲缘关系的两个进程间通信，允许一个进程和另一个与它有共同祖先的进程进行通信。
    - 命名管道：命名管道克服了管道没有名字的限制,因此,除具有管道所具有的功能外,它还允许无亲缘关系进程间的通信。
    - 信号(Signal)：用于通知接受进程有某种事件发生,除了用于进程间通信外,进程还可以发送信号给进程本身
    - 消息(Message)队列:消息队列是消息的链接表,包括 Posix 消息队列 system V 消息队列。
    - 共享内存:使得多个进程可以访问同一块内存空间.
    - 信号量(semaphore):主要作为进程间以及同一进程不同线程之间的同步手段。
    - 套接字(Socket):更为一般的进程间通信机制,可用于不同机器之间的进程间通信。

37. mysql 间隙锁
    1. 加锁的基本单位是（next-key lock）,他是前开后闭原则
    2. 插入过程中访问的对象会增加锁
    3. 索引上的等值查询--给唯一索引加锁的时候，next-key lock升级为行锁
    4. 索引上的等值查询--向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
    5. 唯一索引上的范围查询会访问到不满足条件的第一个值为止
 
38. redis和memcache的优劣
    - redis数据结构更加丰富，memcache的值都是简单的字符串
    - redis比memcache快
    - redis可以持久化数据
    - redis单个value大小可达1G(String value 最大512M)，memcache只有1M

39. redis有几种内存淘汰策略
    - 返回错误
    - allkey-lru：尝试回收最少使用的建
    - volatile-lru：在过期集合中尝试回收
    - allkey-random：随机回收
    - volatile-random：在过期集合中随机回收
    - volatile-ttl：回收过期时间短的key
    
40. spring ioc
    - 由spring ioc负责创建对象，管理对象，装配对象，配置对象，并且管理这些对象的生命周期。
    — 可以解耦，支持加载服务时的饿汉初始化和懒加载

41. ApplicationContext 的实现
    - FileSystemXmlApplicationContext，从XML文件中加载bean的定义；ClassPathXmlApplicationContext WebXmlApplicationContext

42. 有哪些IOC依赖注入的方法
    - 构造器注入，setter方法注入，
    
43. bean的生命周期
    - spring容器从XML文件中读取bean的定义，并实例化bean。
    - spring根据bean的定义填充所有属性。
    - bean实现了BeanNameAware，spring传递bean的id到setBeanNamef方法
    - bean实现了BeanFactoryAware，传递BeanFactory 给setBea
    - 实现了任何bean相关联的，BeanPostProcessors，Spring 会 在 postProcesserBeforeInitialization()方法中调用
    - 如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。
    - 如果有BeanPostProcessors和bean关联，这些bean的postProcessAfterInitialization()方法将被调用 。
    - 如果bean实现了DisposableBean，它将调用destroy()方 法 。
    
44. rabbitMq 怎么保证消息的可靠性和幂等性
    - 首先对于发送端来说，采用confirm模式，发送消息的时候会有一个唯一ID，如果写入rabbitmq 会回调ack，如果失败会回调nack
    - 对于rabbitmq来说，要开启queue持久化和消息持久化，配合confirm，消息写入磁盘才会是ack
    - 消费者要关闭rabbitmq的自动确认，采用手动确认的方法。
   
45. 缓存 数据库 数据保证一致
    - 延时双删，删除redis -> 删除db -> sleep -> 删除redis
    - 异步更新缓存(基于订阅binlog的同步机制)

     
46. 设计模式

47. 为什么 set list map 不实现cloneable 和 serializable 
    - 克隆 和 序列化 的含义是和具体实现相关的，所以应该由具体的集合实现类去实现

48. Arrays.sort 的实现
    - 新的快排方式，原本的快排是采用一个轴点来进行分而治之，新的方式采用两个轴 数据分为三份
        
    
#### 系统设计

美团

1. 缓存穿透问题，空值也缓存，那这个值插入了 缓存和数据库数据不一致了
    - 首先在接口层做校验，对于非法请求直接拦截
    - 布隆过滤器，将可能存在的数据都放进布隆过滤器
    - 将空值也缓存起来，过期时间可以设置短一点，当这个数据插入或更新时，同时也写入缓存
- redis集群，有个热点key，导致服务负载比较高，该怎么办， 本地缓存，还有什么方案， 那这个热点key 会存在集群哪个节点。  TMC的多级缓存解决方案
    - TMC多级缓存方案
    - 过热的key 固定的，可以放到Nginx层缓存
- 数据库分库分表，什么情况考虑分库 什么情况考虑分表， 如果一个表访问量比较大，采用分库还是分表
    - 分库是按业务来说，订单中心 合同中心，不同的业务使用不同的库
    - 分表是表体量太大
- 秒杀，有10个商品，怎么设计
    - redis中存库从
    - 设计令牌，拿到令牌的才能去买
    - 限流，前多少执行，后面的请求直接丢弃
    
- mysql 主从，从库会有延迟，那插入数据 又要及时查的 怎么考虑
    - 尽量让主库的DDL快速执行。
    - 就是主库是写，对数据安全性较高，比如 sync_binlog=1 从库可以 sync_binlog=0 innodb_flushlog=0
    - 采用比主库还好的硬件作为从库
    - 避免大事务，将大事务拆成一个个小事务执行
    - 这种及时的查询可以增加一个cache层进行查询。 或者这种读取查主库
    
- 对于一个 上亿的表，记录有商品id 和 count ，卖的最多的商品，实时查 离线 怎么搞
- redis 分布式锁 底层怎么实现
    
- 幂等性怎么保证，除了唯一标识还有什么方案
    - 唯一索引，防止新增脏数据
    - token机制，防止页面重复请求。
    - 悲观锁 select * from xx where id = XX for update， id需要是主键或唯一索引
    - 乐观锁，版本号实现
    - 分布式锁
    - 状态机幂等，订单状态流转，不可能向前一个状态变更，
    - 对外提供的接口可以 source + seq序列号
- springboot main函数注解，配置文件有几种，property 可以导入yml么
    - springbootApplication
    - EnableEurekaClient
    - EnableFeignClient
    - ImportResource
    - ServletCommponentScan

58

- cpu过高怎么排查
    - top 命令找到CPU最高的pid
    - top -Hp <pid> 找到对应的线程  
    - jstack 出线程运行情况
    - 可能情况
        - FullGC过多
        - 死循环
    
- 线程池的状态
    - Running、ShutDown、Stop、Tidying、Terminated。
    - running -> shutdown  running -> stop
    - shutdown -> tidying  stop -> tidying
    - tidying 执行完钩子函数 terminated 会 tidying -> terminated
- redis 主从同步，分布式锁，主库挂了，从库还没同步数据
    - min-slaves-to-write 3
    - min-slaves-max-lag 10
    - redlock 假设有N个redis master，对单个redis进行获取锁或解锁，如果保证 N/2 + 1 个锁，就认为获取了锁，否则则认为没有获取锁。
- 栈帧里存放着什么
    - 局部变量 操作栈 动态链接 返回信息
- jvm那个区域不会有内存溢出
    - 程序计数器
- mysql为什么用B+
    - B+树的磁盘读写代价更低
    - B+树的查询效率更加稳定
    - B+树更适合区间查找
- G1收集器的特点，什么收集器可以和cms一起使用
    - G1 1 并行与并发（G1可以使java程序以并发的方式运行） 2 分代收集 G1 可以单独承担整个堆的收集  3 空间整合 局部看复制算法 整体标记整理 4 可预测的停顿
    - 单线程复制算法 和 ParNew都可以和cms垃圾回收器一起使用
- 事务，幻读，不可重复读
- CounDownLatch原理
- hashmap 怎么扩容， 转换为红黑树的条件 只有长度到8？
- 快排
    - 分而治之
- hashmap的结构
    
- 设计一个偏向锁？？ 这是什么问题
- sleep 和 wait的区别，wait属于那个类的，Object，为什么呢
    - sleep是Thread的方法，用于控制自身流程，吧线程暂停指定的时间，吧执行机会让给其他线程，不会释放锁，sleep必须捕获异常，可能被中断。
    - wait是Object的方法，用于线程间的通信，使当前拥有该对象锁的线程挂起等待，wait必须在synchronized方法中执行，不需要捕获异常，
    - 因为java提供的锁是对象级的，而不是线程级的，每个对象都有锁，通过线程获得，如果线程需要等待某些锁，调用锁对象的wait方法即可。
- happen before原则 是什么
    - 如果一个操作hb另一个操作，则第一个操作的执行结果对第二个操作可见，而且第一个操作的执行顺序在第二个操作之前
    - 两个操作存在hb，并不意味这java平台具体实现按hb指定的顺序来执行，如果重排序之后的执行结果和hb的执行结果是一致的，则也是允许的
- happen before的具体规则
    - 程序顺序执行规则：一个线程中的每个操作，hb于这个线程中后续的任意操作
    - 监视器锁规则：对一个锁的解锁，hb于随后对这个锁的加锁
    - volatile变量规则：对一个volatile变量的写，hb于这个变量的读
    - 传递性规则：如果A hb B，B hb C，则 A hb C
    - start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
    - Join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
    - 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
    - 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。
- 建立 索引的原则
    1. 在经常用作过滤器的字段上建立索引； 
    2. 在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引； 
    3. 在不同值较少的字段上不必要建立索引，如性别字段； 
    4. 对于经常存取的列避免建立索引； 
    5. 用于联接的列（主健/外健）上建立索引； 
    6. 在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定； 
    
- es 倒排索引，范围查找是什么样的结构

- java 堆外内存泄露怎么去定位

- nio了解什么

- redis zset 跳跃表的原理 查询复杂度，为什么不用红黑树

- 年轻代 从 1G调整到2G 回收时间可能会发生什么变化

- 给es设置过分片没有

- 堆外内存怎么操作

好未来

- mybatis 一级缓存和二级缓存
    - 一级缓存针对一个sqlSession而言，参数完全相同，一个sqlsession调用一个mapper，如果没有声明需要刷新，缓存没超时，则会返回缓存的数据
    - 一级缓存分布式情况会出现脏读，而且目前无法关闭，可以设置为statement，查询完最后如果是这个状态则会清空缓存
    - 和spring整合之后，如果不是同一个事务中的每个mapper查询，都是新建了一个SQLSession的
    
    - 二级缓存是指mapper映射文件，多个SQLSession去查同一个mapper文件，相同的sql查询会缓存起来

- Tomcat调优
    - 内存优化 -xms -xmx -XX:PermSize=512M -XX:MaxPermSize=1024m
    - Connector 优化，默认200个连接，
    - IO优化，阻塞IO   NIO AIO
    - 开启线程池
    - 添加Listener JreMemoryLeakPreventionListener是用来预防JRE内存泄漏



























