---
title: 
date: 2020-03-24 14:40
comments: false
tags: 
- java
- 总结
categories: 
- java
- 总结
keywords:
- 总结
---

#### 个人介绍

我叫冯凯，我现在在闪银奇异工作，我们公司主要业务是金融助贷业务，我们部门主要负责对接放款的资金方，我最近负责的项目内容有 合同系统、签章平台、短信平台 和 平台系统相关内容。

#### 项目经验

平台系统（后台）没什么说的。

合同系统是整个助贷业务的合规基础，合同系统从0到1，切入到助贷业务环节中，尽可能的从借贷业务中剥离开来。合同系统的难点主要在于从0-1，从业务上讲，合同不一定影响放款流程，但是对于监管抽查、客诉、资方、保险等情况是需要合规证据的，所以从业务上来讲保证合同的不缺失、不存储错类型是一个难点。解决方案 配置化规则+合同模板的基础 去检查放款订单的合同，对于缺失+多余的需要人工check，完善规则或者模板。
复杂性 在于：合同模块开始是不存在的，之前耦合在项目中的资方模块 有很多不在管理中，迁移改造没有做，对于新上资方 对接人员的处理不一定完善，合同在业务上地位不是很高，属于事后才会关心，业务上以放款成功 放款时效为主。


签章平台是对整个公司内部签章提供服务的系统，业务不复杂，主要对接第三方系统，目前有即享和法大大。并发每秒也就50.项目难点在于高峰时期出现过几次服务反应很慢，重启解决。事后寻找原因，系统中对于用户的CA信息进行缓存，但是身份证采用加密方式进行处理，可逆加密AES，由于签章可能会发生在各个环节，有可能用户并没有做四要素健全，但是缓存了CA证书，因此在用户路由给资方时增加了对用户姓名和签章平台缓存姓名进行校验，不一致人工去check（历史数据导致，后续吧历史数据进行对比，观察后去掉了这个环节），由于签章请求，路由服务的高峰都在早上10点左右，大量的加解密占用了系统资源，导致JVM频繁回收（1秒左右一次）PSYoungGen 新生代（1.3G），ParOldGen 老年代 （4G)。跟随这业务 用户中心成立，都对接到用户中心，加密改成md5                                 


短信平台 是给公司内部提供具体发送短信，邮件，智能外呼机器人、push的服务，主要采用异步的方式进行交互，根据不同业务属性（验证码短信、营销短信、行业短信等）进行资源分配和隔离。处理线上问题，解决发送速度问题，AWS邮件发件过慢，由于业务和短信平台公用一个账号，AWS对于接口，每秒速率，日限额均有限制，单点服务，单线程处理，赛托外呼 等 池化技术，使用java延迟队列，设定延迟时间，每个node是一个延迟任务，超过容量限制 或者 达到时间会 进行批量处理。


#### 基础知识

1. java集合知道哪些？
    - List:ArrayList, LinkedList, Vector
        - ArrayList 数组，扩容变成以前的1.5倍
        - LinkedList 链表
        - Vector 数组，线程安全，扩容变成以前的2倍
    - set:HashSet, LinkedHashSet, TreeSet
        - HashSet 去重，可有一个null，继承HashMap实现
        - LinkedHashSet 有序的，默认是插入顺序，继承于LinkedHashMap实现
        - TreeSet 有序，Comparator 元素比较大小的顺序，继承于TreeMap实现
    - Map:HashMap, LinkedHashMap, TreeMap
        - HashMap hash表，查找快，数组+桶
        - LinkedHashMap 有序，插入顺序，内部node 在维护成一个双向链表
        - TreeMap 有序，Comparator 元素比较大小顺序，红黑树底层实现

2. HashMap
    HashMap使用数组和桶进行存储，当hash中的元素超过数组大小*负载因子的时候就会进行扩容。hashmap为什么用红黑树而不用其他树：AVL是完全平衡二叉树，查找删除修改的时间复杂度都是 O(lgn),ConcurrentHashMap中是加锁的，本质是读写锁，如果写冲突就会等待，红黑树的插入更快。红黑树允许局部的很少不平衡，avl在调整平衡代价比较高。hashmap为什么8的之后树化：红黑树的平均查找复杂度是O(lgn)，链表的平均 是 n/2，当长度为8是，红黑树的查找时间是3而链表是4，这样才有必要转化为树。小于6转化为链表，中间有个差值7，避免了频繁的树和链表相互转化

3. String为什么是final
    1 为了实现字符串池 2 为了线程安全，同一个字符串可被多个线程共享 3 String是final可以创建后保证hashcode不变

4. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么
    快速失败，快速失败为集合类在遍历的过程不允许被修改，如果mod修改次数发生了变化就会抛出异常；安全失败是JUC下集合类，在遍历的时候会先复制出来一份然后进行遍历。
    
5. synchronized 的实现原理以及锁优化
    - synchronized是jvm实现的一种互斥同步锁，同时也是支持可重入的，synchronized修饰代码块的时候在编译后，会在代码块前后出现monitorentry和monitorexit两个字节码指令，当虚拟机执行到monitorentry的时候，会尝试去获取对象的锁，如果没有被锁定或已持有锁，就吧锁的计数器+1；当执行到monitorexit时候会吧锁计数器-1，如果锁的计数器是0就代表锁被释放。如果修饰在方法上 不会生成这两个指令，会在方法区中增加ACC_SYNCHRONIZED标识，进入方法时会去检测有没有这个标识，有的话会去尝试获取锁。
    - java6之前，monitor的实现完全依赖于底层操作系统的互斥锁来实现，java中的线程和操作系统中的线程有映射关系，如果要将一个线程唤醒或者阻塞都需要操作系统协助，需要从用户态转换为内核态，转换代价比较昂贵，因此对synchronized做了很多优化。
        - 自旋锁：在线程阻塞之前让线程自旋一定时间，可能在这个时间段是锁就被释放了，就不需要切换到内核态。自适应自旋锁：会动态的根据实际情况改变自旋的时间。
        - 偏向锁：当没有竞争时会默认使用偏向锁，JVM利用cas在对象的mark word上设置线程ID，表示这个对象偏向于这个锁，如果另一个线程试图锁定被偏向的对象就是撤掉偏向锁，转换为轻量级锁。
        - 轻量级锁：轻量级锁依赖CAS操作mark word来试图获取锁，如果获取成功则使用轻量级锁，如果失败则膨胀为重量级锁。
    > CAS具有原子性，原子性有CPU硬件指令实现保证，使用JNI调用Native方法调用由C++编写的硬件级别指令，JDK中提供了Unsafe类执行这些操作。

6. synchronized 锁是什么
    锁本质上是monitorentry和monitorexitz字节码指令的一个Reference类型的参数，如果指明了对象则加锁的就是该对象；如果修改非静态方法，表示此方法对应的对象是锁对象；如果修饰的是静态方法，表明此方法对应的类对象是锁对象。当一个对象被锁住的时候，对象里使用synchronized的方法都会被锁住。
    
7. 乐观锁的不足
    - 乐观锁只能保证一个共享变量的原子操作。如果有多个变量要实现原子性，就满足不了。
    - 长时间自旋会导致CPU的开销变的很大。
    - ABA问题，引入版本号

8. ReentrantLock 和 synchronized 有什么不同
    synchronized是通过在对象的mark word上增加标记来实现的，是jvm原生实现的。ReentrantLock是通过一个volatile修饰的int的state，保证每个线程都能对该state可见和修改，就是AQS的一套。ReentrantLock可实现等待中断，带超时的获取锁尝试，可判断是否有线程等待获取锁，可响应中断，可实现公平锁

9. AQS是什么
    - AQS是一个构建锁和同步器的框架。内部定义了一个volatile int state变量表示同步状态，当一个线程调用lock方法时，state为0表明没有线程占用这个资源，可以获得锁并将state设置为1；如果state为1，说明有线程占用了共享资源，其他线程必须进同步队列等待。
    - AQS通过内部Node类来实现一个双向链表的同步结构，来完成线程获取锁的排队现象。Node类是对访问同步代码的线程进行了封装，包含了线程本身和状态waitStatus。每个Node关联其prev节点和next节点，方便线程释放锁的时候唤醒下一个等待线程。Node分为共享模式和独占模式，共享模式允许多个线程占用同一资源（如：信号量），独占模式只能有一个线程占用，其他线程必须等待。
    - AQS通过内部类ConditionObject构建等待队列，Condition调用await后，线程会进入等待队列，调用signal后会从等待队列进入阻塞队列。
    
10. 还了解JUC下的什么类
    - CountDownLatch、 CyclicBarrier、 Semaphore。
    - ConcurrentHashMap、ConcunrrentSkipListMap（有序的）、CopyOnWriteArrayList线程安全的动态数组
    - ArrayBlockingQueue、 SynchorousQueue、PriorityBlockingQueue 并发队列
    - Executor 线程池
    
11. 谈谈ReadWriteLock和StampedLock
    - ReadWriteLock：多个读操作不需要互斥，如果读锁试图获取锁，此时写锁被其他线程获取，读锁将无法获取，阻塞等待写锁操作完成。当并发读多，并发写少的时候性能会比ReentrantLock和synchronized性能要好。但是大量的读线程也可能导致写线程饥饿。
    - StampedLock：相当于读写锁的优化版本，不仅提供了悲观读的方式，还提供了乐观读的方式，可以支持在读的过程中允许写锁后入，但是要在乐观读中增加判断。
    
12. 谈谈线程池
    - 线程池中的线程被包装为了Worker，是基于AQS实现的，存在方HashSet<Worker> workers的成员变量中，需要执行的任务存放在阻塞队列中，从BlockingQueue中不断取出任务放入worker执行。
    - 线程池常用的参数有 核心线程数、最大线程数、超时时间、时间单位、阻塞队列，线程工厂，拒绝策略。
    - 线程池开始时不启动worker，当有请求时才会创建worker，如果运行的线程数小于corePoolSize，则直接创建线程执行任务，如果大于则加入阻塞队列，如果阻塞队列满了没超过最大线程数，则创建新的线程，如果达大最大线程数则执行拒绝策略。
    
13. java内存模型
    - java内存模型定义了各个变量的访问规则，即虚拟机将变量存储和从内存中取出的底层细节，线程间变量值的传递需要通过主存。

14. 谈谈volatile
    - 保证不同线程对volatile修饰变量的可见性，禁止指令重排序。
    - 通过插入特定的内存屏障来禁止指令重排。
    - volatile修饰的变量在编译后会产生lock前缀的指令，lock前缀的指令会将当前CPU缓存行的数据写回到主存，会使其他CPU缓存行的该数据失效。缓存一致性协议，每个CPU会去嗅探总线上传播的数据来判断自己缓存的数据是否过期，如果数据的内存地址被修改过，则吧当前数据的缓存行设置为无效，用到的时候会去主存中取。

15. ThreadLocal怎么解决并发安全的问题， 使用过程中需要注意什么
    - ThreadLocal为每个线程维护了一个变量的副本，吧共享数据的范围限制在一个线程内，ThreadLocal内有一个map存储变量的副本。
    - 使用ThreadLocal要注意remove，ThreadLocal基于内部的ThreadLocalMap实现，这个map的key是一个弱引用，但是key被回收后value不会被回收，所以当变量不在使用时要注意remove

16. Thread中stop和suspend为什么不建议使用
    - stop是不安全的，它会解除线程获取的锁定，其他线程在这时候进行检查和修改可能会出现难以定位的问题。
    - suspend方法容易发生死锁，调用此方法目标线程会停下来，但是不会释放持有的锁。

17 sleep和wait有什么区别
    - sleep是Thread的方法，让线程睡眠某个时间，不会释放此时持有的锁。
    - wait指在一个同步锁内，释放自己的锁让其他线程先执行，只有其他线程调用的notify方法，会通知此线程可以去竞争锁，但不一定会马上获取到锁。
    
18. 线程有几种状态
    新建、就绪、运行、挂起、死亡

19. 现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执行？
    join方法，三个线程，T1.start() T1.join() T2.start() T2.join T3.start
    
20. 用 Java 实现阻塞队列
    通过wait和notify来实现，放元素，如果满了则wait，否则添加然后notify；取元素，如果没有则wait，否则取出然后notify返回

21. mysql InnoDB中的事务隔离级别
    - read uncommitted：读未提交
    - read committed：读已提交
    - repeatable read：可重读
    - serializable ：串行事物

22. mysql text和blob有什么区别
    区别是blob在排序和比较时候区分大小写，而text在比较和排序时不区分大小写

23. 数据库的三范式
    - 第一范式：数据库表的每一个字段都是不可分割的
    - 第二范式：数据库的非主属性只依赖于主键
    - 第三范式：不存在非主属性对关键字的传递函数依赖

24. mysql有哪几种锁
    - MyISAM支持表锁，InnoDB支持行锁和表锁，默认是行锁。
    - 表锁开销小，加锁快，不会出现死锁。锁的颗粒度大，锁冲突的概率高，并发量最小。
    - 行级锁，开销大，加锁慢，会出现死锁。发生锁冲突的概率下，并发量大。

25. mysql数据优化
    - 优化数据类型
        - 避免使用NULL值，NULL值需要特殊处理，大多数时候应该使用NOT NULL，或使用一个特殊值0，-1等作为默认值
        - 使用更小的字段，mysql是从磁盘上读取数据缓存到内存，使用CPU的周期和磁盘IO读取，越小的数据占用空间越少
    - 小心字符集转换
    - 优化子查询 子查询mysql查询优化引擎不是总是有效，可以考虑转换为连接查询
    - 优化 union ，union不会出现重复数据，并会对数据进行排序，比较浪费资源，可以用union all 替代，如果不存在重复数据

26. 知道哪些存储引擎
    - MyISAM：不支持行锁、事务、外键，执行读取速度很快，不占用大量资源和内存
    - InnoDB：InnoDB底层存储结构为B+树，B树的每个节点对应innodb的一个page，page大小是固定的，一般设为16k。其中非叶子节点只有键值，叶子节点包含完整数据。
    - Memory：数据是放在内存中的并默认使用HASH索引，因此访问速度很快。
    
27. MongoDB了解么
    - 在MongoDB中每一条记录都是一个Document。特点是高性能、易部署、易使用，存储数据方便。面向集合存储，易存储对象类型数据；支持动态查询；支持完全索引；使用高效的二进制数据存储；文件存储格式是BSON。
    - 性能很高，适合作为持久化缓存层；适合存储大尺寸，低价值的数据
    
28. 类加载过程知道么
    - 分为7个过程，加载、验证、准备、解析、初始化、使用、卸载
    - 加载：根据这个类的全限定名获取到二进制流，在内存中生成class对象，作为该类的数据访问入口。
    - 验证：保证class文件中的信息不会危害到虚拟机。文件格式验证、元数据验证、字节码验证、符合引用验证
    - 准备：为类的静态变量分配内存并初始化为默认值
    - 解析：

    
#### 系统设计




























