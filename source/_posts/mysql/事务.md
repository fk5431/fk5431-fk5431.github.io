---
title: mysql事务
date: 2019-12-23 22:11
comments: false
tags: 
- mysql
- 事务
categories: 
- mysql
- 事务
keywords: 
- mysql
- 事务
---

### mysql事务

在mysql中，只有使用InnoDB（还有NDB）存储引擎才能支持事务。事务是由一组sql语句组成的逻辑单元，要么全部执行成功，要么全部执行不成功。

#### 事务的四大特征

一般来说，事务必须满足四个条件（ACID）：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。 

- 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。事务在执行的过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务没有执行过一样。
- 一致性：在事务开始之前和事务结束之后，数据库的完整性没有被破坏。（数据库某些操作的原子性和隔离性都是保证一致性的一种手段）
- 隔离性：数据库允许多个事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据不一致。
- 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

#### 事务的隔离级别

事务在并发执行的时候可能会发生以下的问题：

- 脏写：如果一个事务修改了另一个未提交事务修改过的数据，那就发生了脏写。例如：
    | 发生时间 | A事务 | B事务  |
    | ------- | ----  | ----- |
    |    1    | begin |       |
    |    2    |       | begin |
    |    3    |       | update table set name = 'A' where id = 1 |
    |    4    | update table set name = 'B' where id = 1      |  |
    |    5    | commit     |  |
    |    6    |      | commit  |
    
    如果像上面B事务把name更新为了A，然后A事务又把name更新为B，这样就发生了脏写。
- 脏读：如果一个事务读到了另外一个未提交事务修改的数据，那就发生了脏读。例如：
     | 发生时间 | A事务 | B事务  |
     | ------- | ----  | ----- |
     |    1    | begin |       |
     |    2    |       | begin |
     |    3    |       | update table set name = 'A' where id = 1 |
     |    4    | select name from table where id = 1      |  |
     |    5    | commit     |  |
     |    6    |      | commit  |
     如果A事务此时读到的name是A，但是B事务还没有提交，读到了B事务未提交修改的数据，这种现象就是发生了脏读。
- 不可重复读：如果一个事务只能读到另一个已经提交的事务修改的数据，并且其他事务每对该数据进行一次修改提交后，该事务都能查询到最新的值，这就发生了不可重复读。
- 幻读：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原来的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，这就发生了幻读。

这几个问题按照严重性来排序：脏写>脏读>不可重复读>幻读

在SQL标准中设立了四个隔离级别：
- READ UNCOMMITTED：未提交读。
- READ COMMITTED：已提交读。
- REPEATABLE READ：可重复读。
- SERIALIZABLE：可串行化。

|  隔离级别  |  脏读  |  不可重复读  |  幻读  |
|  -------  |  ----  |  --------  |  ----  |
| READ UNCOMMITTED | Possible | Possible | Possible |
| READ COMMITTED | Not Possible | Possible | Possible |
| REPEATABLE READ | Not Possible | Not Possible | Possible |
| SERIALIZABLE | Not Possible | Not Possible | Not Possible |

也就是说：

- READ UNCOMMITTED隔离级别下，可能发生脏读、不可重复读和幻读问题。
- READ COMMITTED隔离级别下，可能发生不可重复读和幻读问题，但是不可以发生脏读问题。
- REPEATABLE READ隔离级别下，可能发生幻读问题，但是不可以发生脏读和不可重复读的问题。
- SERIALIZABLE隔离级别下，各种问题都不可以发生。

> 因为脏写产生的问题太严重，不论是哪种隔离级别，都不允许脏写的情况发生。

MySQL中默认的事务隔离级别是REPEATABLE READ。

#### MVCC（多版本并发控制）

MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。

这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

##### 版本链

使用InnoDB存储引擎的表，在它的聚簇索引记录中都包含两个必要的列（row_id不是必要的，如果创建的表中有主键或非空的UNIQUE键时都不会包含row_id）：

- trx_id：每次一个事务对某条局促索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。
- roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列相当于一个指针，可以通过它来找到该记录修改前的信息。

每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为没有更早的版本），可以将这些undo日志都连起来，串成一个链表，就像如下：

![版本链](../../../uploads/mysql/transaction/transaction1.jpg)

对该记录每次进行更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，这个链表就叫做版本链，版本链的头结点是当前记录的最新值，每个版本中还包含该生成该版本时对应的事务ID。

##### ReadView

对于使用READ UNCOMMITTED 隔离级别的事务来说，可以读到未提交事务修改的记录，所以直接读取记录最新的版本；对于使用SERIALIZABLE隔离级别的事务，采用加锁的方式来访问记录；对于使用READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，都要保证读到已提交的事务修改的记录，这就需要判断版本链中那个版本是对当前事务可见的。因此有了ReadView概念：

- m_ids：表示生成ReadView时当前系统中活跃的读写事务的事务ID列表。
- min_trx_id：表示生成ReadView时当前系统中活跃的读写事务中最小的事务ID。
- max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。
— creator_trx_id：生成该ReadView的事务的事务ID。

有了ReadView，在访问某条记录的时候，就可以按下面的步骤判断记录的某个版本是否可见：

1. 如果被访问版本的trx_id属性值和ReadView中的creator_trx_id值相同，说明访问的自己修改的记录，可以被当前事务访问。
2. 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，说明生成该版本事务在当前事务生成ReadView前已提交，可以被当前事务访问。
3. 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，就需要判断trx_id是否在m_ids列表中，如果在说明创建ReadView时生成该版本的事务还是活跃的，该版本不可被访问；如果不在，说明创建ReadView时生成该本的事务已被提交，可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

>  READ COMMITTED 和 REPEATABLE READ的不同是在生成ReadView的时机不同。READ COMMITTED会在每次读取数据之前都生成一个ReadView，REPEATABLE READ会在第一次读取数据时生成一个ReadView。






















