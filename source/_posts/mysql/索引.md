---
title: mysql索引（B+)
date: 2019-12-22 17:24
comments: false
tags: 
- mysql
- 索引
- B+
categories: 
- mysql
- 索引
- B+
keywords: 
- mysql
- 索引
- B+
---

### MySQL的B+树索引

在MySQL中记录都存储在数据页中，各个数据页可以组成一个双向链表，每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页会为它里面的记录生成一个页目录，在通过主键查找某条记录的时候可以用二分查找法快速定位对应的槽，然后在遍历该槽对应的分组记录即可快速找到对应的记录。

如果没有建立索引，在mysql中查找记录可分为2种情况：

- 以主键为搜索条件（如果没有设置主键，mysql也会隐式的生成主键）：在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 以其他列作为搜索条件：因为在数据页中没有对非主键列建立所谓的页目录，所以无法快速定位到对应的槽。所以只能从最小记录开始遍历单链表中的每条记录，然后对比搜索条件，显然这样的效率是非常慢的。

#### InnoDB中的索引方案

InnoDB采用存储数据的数据页来来存储目录项，只不过目录项中的两列是主键和页号，通过数据页中记录头信息中record_type来区分是目录项还是数据页。

- 0：普通的用户记录
- 1：目录项记录
- 2：最小记录
- 3：最大记录

所以记录在InnoDB的索引存储下来可能如下：

![索引](../../../uploads/mysql/index/1.jpg)

多条记录存储在一个页中，以单链表的方法存储，多个数据页组成了双向链表，都是按索引值从小到大的。然后生成一个数据页来存储目录项记录。目录项和数据页的区别如下：

- 目录项记录的record_type值是1，而普通用户记录的record_type值是0。
- 目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。
- 数据页记录头信息中的min_rec_mask的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都是0。

这样根据索引去查找一条记录的时候，先到存储目录项记录的页，也就是页30中通过二分法快速定位到对应目录项，然后在到对应存储用户记录去查找到对应的记录。

InnoDB中规定一个数据页的大小是16KB，因此能存放的目录项也是有限的，当表中记录太多导致一个数据页不足以存放这么多目录项，那就在分配一个数据页存储目录项，然后这些存储目录项的数据页也组成了一个双向链表：

![索引](../../../uploads/mysql/index/2.jpg)

此时我们在查找一条数据的时候，需要先确定目录项记录页，然后通过目录项记录页确定用户记录真实所在的页，最后在真实存储用户记录的页中定位到具体的记录。
这样如果目录项记录页非常多(用户存储记录量非常大)，因为这些目录项记录页相互也不挨着，是通过双向链表来连接着，这样第一步定位就会很慢。此时为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![索引](../../../uploads/mysql/index/3.jpg)

随着表中记录的增加，这个目录的层级还会增加，将示意图简化下就如下：

![索引](../../../uploads/mysql/index/4.jpg)

这样的一个结构就是B+树，不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为叶子节点或叶节点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中B+树最上边的那个节点也称为根节点。

##### 聚簇索引

1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    - 页内的记录是按照主键的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
    - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
2. B+树的叶子节点存储的是完整的用户记录。所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

具有这两种特性的B+树为聚簇索引，所有完整的用户记录都存储在这个B+的树的叶子节点处。这种聚簇索引并不需要在MySQL语句中显示的用INDEX去创建，InnoDB存储引擎能自动的创建聚簇索引。在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

##### 二级索引（非聚簇索引）

聚簇索引是按照主键的顺序来进行排序的，如果想按表中其他列进行查询，为了查询速度就需要以其他列来建立索引，这样的索引是二级索引。
二级索引就是在建立了一颗B+树，这个B+树的排序规则是按指定索引列来进行排序的，B+树的叶子节点存储的也不是完整的用户记录，而是指定列+主键。
我们通过二级索引查询数据的时候：
1. 确定目录项记录页（通过根节点来进行查找）。
2. 通过目录项记录页确定用户记录真实所在的页。
3. 在真实存储用户记录的页中定位到具体的记录。
4. 叶子节点只存储了主键和二级索引列值，如果要查询的字段还包括其他字段，就需要根据主键在去聚簇索引中进行查询。

因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引。

##### 联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照A2和A3列的大小进行排序，这个包含两层含义：

- 先把各个记录和页按照c2列进行排序。
- 在记录的c2列相同的情况下，采用c3列进行排序。

这样以c2和c3列的大小为排序规则建立的B+树称为联合索引。建立联合索引也只会生成一颗B+树

##### B+树索引根页面

B+树的形成过程如下：

- 每当为某个表创建一个B+树索引的时候，都会为这个索引去创建一个数据页。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有用户记录，也没有目录项记录。
- 当向表中插入数据时，就先吧记录存储在根节点的数据页中。
- 当根节点可用空间使用完后继续插入，此时会将根节点数据页中的数据全都复制到一个新分配的数据页中（例如页A），然后对这个页进行页分裂的操作（得到的新页为页B）。这时新插入的记录根据键值的大小就会被分配到页a或者页b中，而根节点便升级为存储目录项记录的页。

一个B+树索引的根节点被创建后就不会再被移动。这样我们对一个表建立索引，那它的根节点的数据页的页号就会被存储在某个地方，然后InnoDB存储引擎用到这个索引的时候，就会从固定的地方取出来，从而去访问。

#### B+树索引的使用

##### 索引的代价

- 空间上的代价：每建立一个索引就要建立一个B+树，每一个B+树的每一个节点都是一个数据页，一个页会默认占用16K的大小，一颗很大的B+树由很多数据页组成，会占用不少的空间。
- 时间上的代价：每次对表中的数据进行增删改查的时候，都需要去修改各个B+树。B+树每层节点都是按照索引列值按小到大排列组成了双向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。

##### B+树的适用条件

- 全值匹配：如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。通过联合索引来进行全值匹配，where中条件的顺序不会影响查询效率，优化器会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。
- 匹配左边的列：我们在搜索语句中也不需要包含联合索引中所有的列，只包含左边的就行，也可以包含多个左边的列。因为联合索引，B+树是先按列A排序，如果列A相等在按列B排序，以此类推，所以我们想使用联合索引中尽可能多的列，那搜索条件必须是联合索引中从最左边连续的列。
- 匹配列的前缀：索引按列的大小进行排序，字符串排序的本质就是比较哪个字符串大一点儿，会按第一个字符相比较，相等则比较第二个字符，以此类推。所以字符串的前缀也是排好序，因此在where条件中使用 'ab%' 这样的前缀匹配也会使用到索引。
- 匹配范围值：所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。
- 精确匹配某一列并范围匹配另外一列：对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找。
- 用于排序：如果ORDER BY子句里使用到了索引列，就有可能省去在内存或文件中排序的过程。（使用联合索引，ORDER BY中排序列排序的顺秀需要和联合索引的顺序一致）
- 不可以使用索引进行排序的几种情况：
    - ASC、DESC混用：对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC规则排序，要么都是DESC规则排序。
    - WHERE子句中出现非排序使用到的索引列：如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的。
    - 排序列包含非同一个索引的列：有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序。
    - 排序列使用了复杂的表达式：要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式。
- 用于分组：和使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。

##### 索引的选择

- 只为用于搜索、排序或分组的列创建索引：只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了。
- 考虑列的基数：列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2, 5, 8, 2, 5, 8, 2, 5, 8，虽然有9条记录，但该列的基数却是3。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。
- 索引列的类型尽量小：数据类型越小，在查询时进行的比较操作越快；数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。
- 索引字符串值的前缀：我们可以只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。（这样的索引无法支持排序的时候使用索引）
- 索引列在比较表达式中单独出现：如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。
- 主键插入顺序：如果一个主键插入的值一会大一会小，会导致页分裂和记录移位，这意味着性能损耗，所以最好让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。
- 冗余和重复索引：冗余和重复索引只会增加维护索引的成本。



















