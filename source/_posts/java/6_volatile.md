---
title: 深入理解volatile
date: 2020-02-24 15:18
comments: false
tags: 
- java
- volatile
categories: 
- java
- volatile
keywords:
- volatile
---

### volatile

volatile是一个类型修饰符。volatile的作用是作为指令关键词，确保本条指令不会因为编辑器的优化而省略。

- 可以保证不同线程对这个变量进行操作时的可见性（一个线程修改了这个变量的值，其他线程可以立即可见）。
- 禁止指令重排序。
- volatile只能保证单次的读写原子性(i++这种操作不能保证)。

#### 实现原理

volatile变量内存可见性是基于内存屏障来实现的。

- 内存屏障又称内存栅栏，是一个CPU指令。
- 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，z为来了保证在不同编译器和CPU上有相同结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉CPU不管什么指令都不能和这条Memory Barrier指令重排序。

> 在volatile修饰的共享变量进行写操作的时候会多出 lock 前缀的指令。

- lock前缀指令在多核处理器下会引发两件事。
    1. 将当前处理器缓存行的数据写会系统内存。
    2. 写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效。
    
> 为了提高处理速度，处理器不直接和内存进行通信，而是将系统内存的数据读到内部缓存(L1，L2等)在操作，但是操作完之后不知道何时会写到内存。
> 如果这个变量被volatile修饰，那么在写操作的时候，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。
> 为了保证各个处理器的缓存是一致的，实现了缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，如果发现自己缓存的值对应的内存地址被修改，当前处理器就会将该值设置为无效状态，当处理器对这个数据进行修改的时候，会重新从内存中读取到处理器缓存中。

#### 有序性的实现

- 为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。
- Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。
- JMM 会针对编译器制定 volatile 重排序规则表。

| 是否能重排序 |  | 第二个操作 | |
| --- | --- | --- | --- |
| 第一个操作 | 普通读写 | volatile读 | volatile写 |
| 普通读写 |  |  | NO |
| volatile读 | NO | NO | NO |
| volatile写 |  | NO | NO |

- 为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。
- 对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。
    - 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
    - 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
    - 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
    - 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。
- volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。


| 内存屏障 | 说明 |
| ------  | --- |
| StoreStore 屏障 | 禁止上面的普通写和下面的 volatile 写重排序。|
| StoreLoad 屏障 | 防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。|
| LoadLoad 屏障 | 禁止下面所有的普通读操作和上面的 volatile 读重排序。|
| LoadStore 屏障 | 禁止下面所有的普通写操作和上面的 volatile 读重排序。|

****
