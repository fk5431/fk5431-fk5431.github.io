---
title: 分布式锁
date: 2020-02-13 16:21
comments: false
tags: 
- redis
- 分布式锁
categories: 
- redis
- 分布式锁
keywords:
- 分布式锁
---

### 分布式锁

分布式应用进行逻辑处理时经常会有并发的问题。例如一个操作要修改用户状态，修改状态需要先读出用户的状态，在内存中进行修改，修改完之后在存储。这样的操作同时进行了就会有并发问题，因为读取和保存不是原子操作。

这时候就要使用分布式锁来限制程序的并发执行。

#### 实现

分布式锁本质上就是在redis设置一个值，当其他进程发现已被设置就放弃或稍后再试。

一般使用setnx命令来实现（set if not exists）指令，只允许被一个客户端占用，使用完之后使用del指令删除释放。

```
> setnx lock true
OK
... do something critical ...
> del lock
(integer) 1
```

但是如果在 setnx 和 del指令执行中间出现异常，导致del没有调用就会陷入死锁，锁永远不会释放。

在拿到锁之后给锁加一个过期时间，这样在中间出现异常也会在5s后释放锁。

```
> setnx lock true
OK
> expire lock 5
... do something critical ...
> del lock
(integer) 1
```

但是在setnx 和 expire过程中如果服务器进程突然挂掉了，就会导致expire得不到执行，也会造成死锁。
问题根源在于setnx 和 expire是两条指令而不是原子指令。
在redis2.8中加入了set指令的扩展参数，可以是setnx 和 expire一起执行。

```
> set lock true ex 5 nx
OK
... do something critical ...
> del lock
```

#### 超时

redis分布式锁不能解决超时问题，如果在加锁和释放锁的过程中执行的业务逻辑时间过长，就会出现问题。此时第一个线程持有的锁过期了，但是中间的业务逻辑还没有执行完成，此时第二个线程就会提前持有这把锁。

有一个稍微安全一点的方案是为 set 指令的 value 参数设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了确保当前线程占有的锁不会被其它线程释放，除非这个锁是过期了被服务器自动释放的。 但是匹配 value 和删除 key 不是一个原子操作，Redis 也没有提供类似于delifequals这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可以保证连续多个指令的原子性执行。

```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

#### 可重入性

可重入性是指线程在持有锁的情况下再次请求加锁，如果一个锁支持同一个线程的多次加锁，那么这个锁就是可重入的。例如ReentrantLock 就是可重入锁。Redis 分布式锁如果要支持可重入，需要对客户端的 set 方法进行包装，使用线程的 Threadlocal 变量存储当前持有锁的计数。

