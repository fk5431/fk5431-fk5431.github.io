<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[线程池阅读]]></title>
      <url>%2F20191115%2Fjavasource%2Futil%2F2_ExecutorService%2F</url>
      <content type="text"><![CDATA[类继承的结构 Executor是最顶层的接口，定义了execute(Runnable runnable)方法。ExecutorService继承了Executor，继承了execute方法，还定义很多接口方法，例如shutdown、isTerminated、submit等方法。 在下面一层是AbstractExecutorService，这是一个抽象类，实现一些很有用的方法供子类使用。 ThreadPoolExecutor是我们线程池的实现。 ThreadPoolExecutorThreadPoolExecutor实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。 我们还可以在它的基础上进行扩展，比如实现定时任务的类 ScheduledThreadPoolExecutor（用来在给定延时后执行异步任务或者周期性执行任务） 就继承自 ThreadPoolExecutor。 构造函数参数123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 我们创建一个线程池参数最全的构造方法如上，这些是我们最关心的参数。 corePoolSize 核心线程数 maximumPoolSize 最大线程数 keepAliveTime 空闲线程的存活时间 unit 存活时间的单位 workQueue 任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。 threadFactory 用于创建线程，一般都使用默认的（Executors.defaultThreadFactory()），我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。 handler 拒绝策略 状态流转123456789private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; COUNT_BITS 设置为 29(32-3)，前三位用于存放线程状态，后29位用于存放线程数CAPACITY = 2^29-1=536870911 即线程池的最大数量RUNNING 111 00000000000000000000000000000 接受新的任务，处理等待队列中的任务SHUTDOWN 000 00000000000000000000000000000 不接受新的任务提交，但是会继续处理等待队列中的任务STOP 001 00000000000000000000000000000 不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程TIDYING 010 00000000000000000000000000000 所有的任务都销毁了,线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()TERMINATED 011 00000000000000000000000000000 terminated() 方法结束后，线程池的状态就会变成这个 RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的 (RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了 SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING STOP -&gt; TIDYING：当任务队列清空后，发生这个转换 TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后 Worker1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; private static final long serialVersionUID = 6138294804551838833L; final Thread thread; Runnable firstTask; volatile long completedTasks; Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; public void run() &#123; runWorker(this); &#125; protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125; Worker是线程池中的内部类，是线程池中真正执行任务的线程，Worker继承了AbstractQueuedSynchronizer（aqs）实现了Runable。Worker中thread是真正的线程；firstTask是在创建线程的时候，如果同时指定了这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的；completedTasks 存放了此线程完成的任务数构造函数传入firstTask，也可以传 null。run方法调用了外部类的runWorker方法。其余的方法用 AQS 操作，来获取这个线程的执行权，用了独占锁。 runWorker123456789101112131415161718192021222324252627282930313233343536373839final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; while (task != null || (task = getTask()) != null) &#123; w.lock(); if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 这个方法由worker线程启动后调用，如果指定了该worker的firstTask，则先执行这个任务，之后通过while循环从队列中取任务。首先lock，然后判断线程池状态大于等于 STOP，那么意味着该线程也要中断。beforeExecute方法是一个钩子方法，留给需要的子类进行实现;然后执行任务;afterExecutey也是钩子方法，将task和异常作为参数，留给子类实现使用;最后将task置为空，准备getTask，worker的完成任数加1，释放独占锁。如果能执行到最后的finally（对线程池进行关闭）有两种可能 1 getTask 返回 null，也就是说，队列中已经没有任务需要执行了，执行关闭。2 任务执行过程中发生了异常。 getTask1234567891011121314151617181920212223242526272829303132333435363738private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //检查状态 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; //减少工作线程的数量，返回null CAS操作 decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); //核心线程是否超时回收 | 线程数大于核心线程数 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 线程数大于最大线程数，因为有可能开发者调用了 setMaximumPoolSize() 将线程池的 maximumPoolSize 调小了，那么多余的 Worker 就需要被关闭 // 并且 线程数 &gt; 1 获取队列为King， if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //减少线程数 返回空 if (compareAndDecrementWorkerCount(c)) return null; //CAS continue; &#125; try &#123; // 到 workQueue 中获取任务 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 此方法有三种可能： 阻塞直到获取到任务返回。()默认 corePoolSize 之内的线程是不会被回收的，它们会一直等待任务) 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭 如果发生了以下条件，此方法必须返回 null: 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置) 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行 execute 方法1234567891011121314151617181920212223242526public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务,创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask) if (workerCountOf(c) &lt; corePoolSize) &#123; //添加任务成功，那么就结束了,返回 false 代表线程池不允许提交任务 if (addWorker(command, true)) return; c = ctl.get(); &#125; //如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 执行的流程很简单，如果当前线程数少于核心线程数直接add一个worker执行，如果大于等于核心线程数会加进任务队列等待worker执行，如果任务队列满了之后，继续添加worker执行，如果此时线程数超过最大线程数就会执行拒绝策略。 拒绝策略CallerRunsPolicy12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; 如果线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。 12345678public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125; 线程池的默认策略，直接抛出异常。 12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; 不处理直接忽略。 123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 把队列队头的任务干掉，然后提交这个任务。]]></content>
    </entry>

    
    <entry>
      <title></title>
      <url>%2F20191114%2Fjava%2F3_classloader%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[HashMap阅读 （1.8|1.7）]]></title>
      <url>%2F20191114%2Fjavasource%2Futil%2F1_HashMap%2F</url>
      <content type="text"><![CDATA[HashMap 内部默认的参数 变量 值 含义 DEFAULT_INITIAL_CAPACITY 16 默认容量 MAXIMUM_CAPACITY 1 &lt;&lt; 30 最大容量 DEFAULT_LOAD_FACTOR 0.75 负载因子 TREEIFY_THRESHOLD 8 链表超过8转为红黑树 UNTREEIFY_THRESHOLD 6 红黑树转为链表的阈值 MIN_TREEIFY_CAPACITY 6 当table的长度小于64时，只是进行扩容 HashMap 内 Node(1.8)123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 内部存储key value的结构，本质是一个链表，其中包括key，value，key value的hash值异或的hash和下一个节点。 HashMap的扰动函数1.8JDK1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 1.7JDK12345678910final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; 自己的高半区和低半区做异或，为了混合原始哈希码的高位和低位，以此来加大低位的随机性。JDK 1.7做了四次右位移异或混合，目的都一致。 HashMap get 方法1.7JDK1234567public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125; 如果key是空值，单独获取 12345678910private V getForNullKey() &#123; if (size == 0) &#123; return null; &#125; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null;&#125; null的key总是存储在table的0index中。 12345678910111213141516final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; 获取非空的key，先根据key的hash值和table的长度得到下标索引，在对应的index上的链表遍历查询。indexFor 即hash值与table.length 相与。 1.8JDK1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 首先进行校验 table不为空 &amp;&amp; table长度大于0 &amp;&amp; table索引位置(使用table.length - 1和hash值进行位与运算)的节点不为空。其次看first节点（索引位节点）是不是目标节点，如果是目标节点则返回。如果是红黑树节点，则调用红黑树的查找节点方法进行查找，如果是链表节点遍历查询。 HashMap put 方法1.7JDK12345678910111213141516171819202122public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 第一步，如果table为空的话进行初始化。第二步，如果key是空，将value存储table[0]中，先遍历如果有更新新值返回旧值，如果没有addEntry。第三步，根据key计算hash值与table.length相与找到index，先遍历如果有更新新值返回旧值，如果没有addEntry。 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; addEntry方法中判断了这个bucketIndex的链表没有冲突且元素size超过负载因子*容量的大小就进行resize的操作，然后重新计算key 的hash值和在table的index，最后进行createEntry。createEntry 在链表中增加了一个节点。 12345678910111213141516171819202122232425262728void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125;void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; resize 方法中调用了transfer，将原数组的中的元素转移到新数组中，这个过程中将链表反转到新数组中，此时多线程进行操作可能会导致链表出现环状，此时get这个key的index是这个环list会导致CPU100%。 1.8jDK123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 如果table为空或者长度为0的时候辉县进行初始化，其次索引位置上的节点为null的时候会创建新的节点。其次判断p节点的key和hash值是否跟传入的相等，如果相等此节点即为要查询的节点；如果p节点是红黑树节点，调用红黑树的putTreeVal查找目标节点；如果p是链表节点，找不到目标节点则创建一个新的节点，如果节点数超过8则转换为红黑树。最后如果e节点不为空，则代表目标节点存在，使用传入的value覆盖该节点的value，并返回oldValue;如果没找到目标节点，超过阈值会执行resize扩容， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 1.老表的容量不为0，即老表不为空 if (oldCap &gt; 0) &#123; // 1.1 判断老表的容量是否超过最大容量值：如果超过则将阈值设置为Integer.MAX_VALUE，并直接返回老表, // 此时oldCap * 2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 1.2 将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap&gt;=16, 则将新阈值设置为原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 2.如果老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值 else if (oldThr &gt; 0) newCap = oldThr; else &#123; // 3.老表的容量为0, 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 4.如果新表的阈值为空, 则通过新的容量*负载因子获得阈值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 5.将当前阈值设置为刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。 threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 6.如果老表不为空，则需遍历所有节点，将节点赋值给新表 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; // 将索引值为j的老表头节点赋值给e oldTab[j] = null; // 将老表的节点设置为空, 以便垃圾收集器回收空间 // 7.如果e.next为空, 则代表老表的该位置只有1个节点，计算新表的索引位置, 直接将该节点放在该位置 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 8.如果是红黑树节点，则进行红黑树的重hash分布(跟链表的hash分布基本相同) else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 9.如果是普通的链表节点，则进行普通的重hash分布 Node&lt;K,V&gt; loHead = null, loTail = null; // 存储索引位置为:“原索引位置”的节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; // 存储索引位置为:“原索引位置+oldCap”的节点 Node&lt;K,V&gt; next; do &#123; next = e.next; // 9.1 如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) // 如果loTail为空, 代表该节点为第一个节点 loHead = e; // 则将loHead赋值为第一个节点 else loTail.next = e; // 否则将节点添加在loTail后面 loTail = e; // 并将loTail赋值为新增的节点 &#125; // 9.2 如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:老表的索引位置＋oldCap else &#123; if (hiTail == null) // 如果hiTail为空, 代表该节点为第一个节点 hiHead = e; // 则将hiHead赋值为第一个节点 else hiTail.next = e; // 否则将节点添加在hiTail后面 hiTail = e; // 并将hiTail赋值为新增的节点 &#125; &#125; while ((e = next) != null); // 10.如果loTail不为空（说明老表的数据有分布到新表上“原索引位置”的节点），则将最后一个节点 // 的next设为空，并将新表上索引位置为“原索引位置”的节点设置为对应的头节点 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 11.如果hiTail不为空（说明老表的数据有分布到新表上“原索引+oldCap位置”的节点），则将最后 // 一个节点的next设为空，并将新表上索引位置为“原索引+oldCap”的节点设置为对应的头节点 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; // 12.返回新表 return newTab;&#125; 在JDK1.8中，resize操作不需要重新计算索引，且迁移新表后数据不会倒置。不需要重新计算hash，只需要用原来的hash值，加上高一位做为索引。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[迭代器模式]]></title>
      <url>%2F20170817%2FDesign_pattern%2F19_iterator%2F</url>
      <content type="text"><![CDATA[迭代器模式介绍迭代器模式：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。（行为型模式）迭代器模式是应该是java中使用的最多的一种设计模式，迭代器模式如下： 抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。 具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。 抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(), 迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。 优缺点和适用场景优点 迭代器简化了聚合的接口 可以提供多种遍历方式 在同一个聚合上可以有多个遍历 缺点 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合 适用场景一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。java本身已经把迭代器做到内部中了，我们一般情况自己很少自定义的迭代器。 DEMO看了JDK源码简单写了一个 首先是抽象迭代器 12345678910package factory.pattern.iterator;/** * Created by FK on 2017/8/17. * 抽象迭代器类 */public interface Iterator&lt;E&gt; &#123; public boolean hasNext(); public E next();&#125; 抽象集合1234567891011package factory.pattern.iterator;/** * Created by FK on 2017/8/17. */public interface List&lt;E&gt; extends Iterable&lt;E&gt; &#123; void add(E e); E get(int index); Iterator&lt;E&gt; iterator(); int getSize();&#125; 抽象集合继承了iterable,iterable可以使得多个迭代器互不干扰12345678package factory.pattern.iterator;/** * Created by FK on 2017/8/17. */public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; 具体的集合实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package factory.pattern.iterator;/** * Created by FK on 2017/8/17. */public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123; private Object[] elementData; private int size = 0; private int index = 0; public ArrayList() &#123; this.elementData = new Object[10]; this.size = 0; this.index = 0; &#125; @Override public void add(E e) &#123; elementData[index++] = e; size++; &#125; @Override public E get(int index) &#123; return (E) elementData[index]; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ConcreteIterator(); &#125; @Override public int getSize() &#123; return size; &#125; private class ConcreteIterator implements Iterator&lt;E&gt;&#123; int cursor; @Override public boolean hasNext() &#123; return cursor != size ; &#125; @Override public E next() &#123; return (E) elementData[cursor++]; &#125; &#125;&#125; 测试类12345678910111213141516171819package factory.pattern.iterator;/** * Created by FK on 2017/8/17. */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;one&quot;); list.add(&quot;two&quot;); list.add(&quot;three&quot;); list.add(&quot;four&quot;); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; String str = iterator.next(); System.out.println(str); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解释器模式]]></title>
      <url>%2F20170811%2FDesign_pattern%2F18_interpreter%2F</url>
      <content type="text"><![CDATA[解释器模式介绍解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。（行为型模式） 解释器模式uml图一般如下： AbstractExpression 抽象解释器 &nbsp;&nbsp;&nbsp;&nbsp; 具体的解释任务由各个实现类完成，具体的解释器分别由TerminalExpression和NonterminalExpression完成。 TerminalExpression终结符表达式 &nbsp;&nbsp;&nbsp;&nbsp;实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。具体到我们例子就是VarExpression类，表达式中的每个终结符都在堆栈中产生了一个VarExpression对象。 NonterminalExpression 非终结符表达式 &nbsp;&nbsp;&nbsp;&nbsp;文法中的每条规则对应于一个非终结表达式，具体到我们的例子就是加减法规则分别对应到AddExpression和SubExpression两个类。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。 Context 环境角色 &nbsp;&nbsp;&nbsp;&nbsp;具体到我们的例子中是采用HashMap代替。 正则表达式就是使用了解释器模式解释器模式在实际的系统开发中使用的非常少，因为它会引起效率、性能以及维护等问题，一般在大中型的框架型项目能够找到它的身影，比如一些数据分析工具、报表设计工具、科学计算工具等等，若你确实遇到“一种特定类型的问题发生的频率足够高”的情况，准备使用解释器模式时，可以考虑一下Expression4J、MESP（Math Expression String Parser）、Jep等开源的解析工具包，功能都异常强大，而且非常容易使用，效率也还不错，实现大多数的数学运算完全没有问题. 优缺点优点解释器是一个简单语法分析工具，它最显著的优点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。 缺点 每个语法都要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来了非常多的麻烦。 解释器模式采用递归调用方法，如果要排查一个语法错误，要一个一个断点的调试下去，会很麻烦。 解释器模式使用了大量的循环和递归，特别是用于解析复杂、冗长的语法时，效率会很低。 DEMO设计一个四则运算（这里只写了加减），可以应用各种模型公式。uml图如下： 代码如下： 抽象解释器 12345678910package factory.pattern.interpreter;import java.util.HashMap;/** * Created by FK on 2017/8/11. */public abstract class Expression &#123; public abstract int interpreter(HashMap&lt;String, Integer&gt; var);&#125; 抽象非终结符表达式，定义文法中的规则 1234567891011121314package factory.pattern.interpreter;/** * Created by FK on 2017/8/11. */public abstract class SymbolExpression extends Expression &#123; protected Expression left; protected Expression right; public SymbolExpression(Expression left, Expression right) &#123; this.left = left; this.right = right; &#125;&#125; 具体的非终结符表达式 123456789101112131415161718package factory.pattern.interpreter;import java.util.HashMap;/** * Created by FK on 2017/8/11. */public class AddExpression extends SymbolExpression&#123; public AddExpression(Expression left, Expression right) &#123; super(left, right); &#125; @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) + super.right.interpreter(var); &#125;&#125; 具体的非终结符表达式 1234567891011121314151617package factory.pattern.interpreter;import java.util.HashMap;/** * Created by FK on 2017/8/11. */public class SubExpression extends SymbolExpression &#123; public SubExpression(Expression left, Expression right) &#123; super(left, right); &#125; @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) - super.right.interpreter(var); &#125;&#125; 终结符表达式 12345678910111213141516171819package factory.pattern.interpreter;import java.util.HashMap;/** * Created by FK on 2017/8/11. */public class VarExpression extends Expression &#123; private String key; public VarExpression(String key) &#123; this.key = key; &#125; @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return var.get(key); &#125;&#125; Calcuator的作用是封装，根据迪米特原则，Client只与直接的朋友Calcuator交流，与其他类没关系。 123456789101112131415161718192021222324252627282930313233343536373839404142package factory.pattern.interpreter;import java.util.HashMap;import java.util.Stack;/** * Created by FK on 2017/8/11. */public class Calculator &#123; //表达式 private Expression expression; public Calculator(String expStr)&#123; Stack&lt;Expression&gt; stack = new Stack&lt;&gt;(); //表达式拆分为字符数组 char[] charArray = expStr.toCharArray(); Expression left = null; Expression right = null; for(int i=0;i&lt;charArray.length;i++)&#123; switch (charArray[i])&#123; case &apos;+&apos; : left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new AddExpression(left, right)); break; case &apos;-&apos;: left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new SubExpression(left,right)); break; default: stack.push(new VarExpression(String.valueOf(charArray[i]))); &#125; &#125; this.expression = stack.pop(); &#125; public int run(HashMap&lt;String, Integer&gt; var)&#123; return this.expression.interpreter(var); &#125;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940package factory.pattern.interpreter;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashMap;/** * Created by FK on 2017/8/11. */public class Test &#123; public static void main(String[] args) throws IOException &#123; String expStr = getExpStr(); HashMap&lt;String, Integer&gt; var = getValue(expStr); Calculator calculator = new Calculator(expStr); System.out.println(&quot;运算结果为：&quot;+expStr +&quot;=&quot;+calculator.run(var)); &#125; public static String getExpStr() throws IOException &#123; System.out.println(&quot;输入表达式&quot;); return (new BufferedReader((new InputStreamReader(System.in)))).readLine(); &#125; public static HashMap&lt;String, Integer&gt; getValue(String expreStr) throws IOException &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for(char ch : expreStr.toCharArray())&#123; if(ch != &apos;+&apos; &amp;&amp; ch != &apos;-&apos;)&#123; if(!map.containsKey(String.valueOf(ch)))&#123; System.out.print(&quot;请输入&quot;+ch+&quot;的值:&quot;); String in = (new BufferedReader(new InputStreamReader(System.in))).readLine(); map.put(String.valueOf(ch),Integer.valueOf(in)); &#125; &#125; &#125; return map; &#125;&#125; 输出结果 123456输入表达式a+b-c请输入a的值:100请输入b的值:20请输入c的值:40运算结果为：a+b-c=80]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[命令模式]]></title>
      <url>%2F20170808%2FDesign_pattern%2F17_command%2F</url>
      <content type="text"><![CDATA[命令模式介绍 在软件系统中，行为请求者与行为实现者通常是一种紧耦合关系，但是有时候，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合关系就不大合适。 将一个请求封装成一个对象，从而是你可用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。命令模式就是对命令进行封装，把发出命令和执行命令分开，请求方并不知道命令是怎么被接受，也不知道命令是否执行，什么时候执行，怎么被执行的；使用命令模式可以使请求成为一个对象，这个对象可以和其他对象一样被存储和传递。 涉及角色 抽象命令（command）：定义命令的接口，申明执行的方法。 具体命令（concreteCommand）：具体命令，实现要执行的方法，它通常是“虚”的表现；通常会有接受者，并调用接受者的功能来完成命令要执行的操作。 接受者（receiver）：真正执行命令的对象。任何类都可能成为一个接受者，只要实现命令要求实现的相应功能。 调用者（invoker）：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。 优缺点优点 解除了请求者与实现者之间的耦合，降低了系统的耦合度 对请求排队或记录请求日志，支持撤销操作 可以容易地设计一个组合命令 新命令可以容易地加入到系统中 缺点 因为针对每一个命令都需要设计一个具体命令类，使用命令模式可能会导致系统有过多的具体命令类 适用场景 当需要对行为进行“记录、撤销/重做”等处理时。 系统需要将请求者和接收者解耦，使得调用者和接收者不直接交互。 系统需要在不同时间指定请求、请求排队和执行请求。 系统需要将一组操作组合在一起，即支持宏命令。 DEMOcommand12345678package factory.pattern.command.demo1;/** * Created by FK on 2017/8/8. */public interface Order &#123; void execute();&#125; concreteCommand 123456789101112131415161718package factory.pattern.command.demo1;/** * Created by FK on 2017/8/8. */public class BuyStock implements Order&#123; private Stock abcStock; public BuyStock(Stock abcStock) &#123; this.abcStock = abcStock; &#125; @Override public void execute() &#123; abcStock.buy(); &#125;&#125; 1234567891011121314151617package factory.pattern.command.demo1;/** * Created by FK on 2017/8/8. */public class SellStock implements Order &#123; private Stock abcStock; public SellStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; @Override public void execute() &#123; abcStock.sell(); &#125;&#125; receive1234567891011121314151617package factory.pattern.command.demo1;/** * Created by FK on 2017/8/8. */public class Stock &#123; private String name = &quot;ABC&quot;; private int quantity = 10; public void buy()&#123; System.out.println(&quot;Stock [ Name: &quot;+name+&quot;,Quantity: &quot; + quantity +&quot; ] bought&quot;); &#125; public void sell()&#123; System.out.println(&quot;Stock [ Name: &quot;+name+&quot;,Quantity: &quot; + quantity +&quot; ] sold&quot;); &#125;&#125; invoker12345678910111213141516171819202122package factory.pattern.command.demo1;import java.util.ArrayList;import java.util.List;/** * Created by FK on 2017/8/8. */public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order)&#123; orderList.add(order); &#125; public void placeOrders()&#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125; TEST123456789101112131415161718package factory.pattern.command.demo1;/** * Created by FK on 2017/8/8. */public class Test &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); BuyStock buyStock = new BuyStock(abcStock); SellStock sellStock = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStock); broker.takeOrder(sellStock); broker.placeOrders(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[责任链模式]]></title>
      <url>%2F20170806%2FDesign_pattern%2F16_chainOfResponsibility%2F</url>
      <content type="text"><![CDATA[责任链模式介绍在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求会在这个链上传递，直到链上某一个对象可以处理这个请求。（行为型模式） 结构图责任链模式的结构像下面这样： 抽象处理者角色（handler）：定义一个处理请求的接口，还可以定义一个后继连接（可选）。 具体处理者角色（ConcreteHandler）：具体处理者接到请求后，如果可以处理就处理请求，如果不能处理就把请求传给下一个继承。 优缺点优点 降低耦合度：client发送请求并不需要知道是哪个对象处理的请求。 责任链可简化对象的相互链接：它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。 增强给对象指派职责的灵活性： 通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 加新的请求处理类很方便。 缺点 不能保证请求一定被处理。 系统性能有一定影响，调试时候不方面，可能造成循环调用。 DEMO责任链模式经常用于过滤，如果要过滤一句话中的文字是，首先定义一个过滤器接口12345678package factory.pattern.chainOfResponsibility;/** * Created by FK on 2017/8/6. */public interface Filter &#123; String doFilter(String str);&#125; 实现过滤HTML标记1234567891011121314package factory.pattern.chainOfResponsibility;/** * Created by FK on 2017/8/6. */public class HtmlFilter implements Filter &#123; @Override public String doFilter(String str) &#123; String r = str; //过滤msg中的HTML标记 r = r.replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;).replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;); return r; &#125;&#125; 实现敏感词过滤1234567891011121314package factory.pattern.chainOfResponsibility;/** * Created by FK on 2017/8/6. */public class SensitiveFilter implements Filter &#123; @Override public String doFilter(String str) &#123; String r = str; //过滤敏感词 r = r.replace(&quot;敏感&quot;, &quot;&quot;).replace(&quot;被就业&quot;, &quot;就业&quot;); return r; &#125;&#125; 控制整个链12345678910111213141516171819202122232425package factory.pattern.chainOfResponsibility;import java.util.ArrayList;import java.util.List;/** * Created by FK on 2017/8/6. */public class FilterChain implements Filter &#123; public List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); public FilterChain addFilter(Filter f)&#123; filters.add(f); return this; &#125; @Override public String doFilter(String str) &#123; String r = str; for(Filter f : filters)&#123; r = f.doFilter(r); &#125; return r; &#125;&#125; 测试1234567891011121314151617package factory.pattern.chainOfResponsibility;/** * Created by FK on 2017/8/6. */public class Test &#123; public static void main(String[] args) &#123; //需要被过滤的语句 String str = &quot;被就业了：），敏感信息，&lt;script&gt;&quot;; //搞一个过过滤链 FilterChain chain = new FilterChain(); chain.addFilter(new HtmlFilter()).addFilter(new SensitiveFilter()); String s = chain.doFilter(str); System.out.println(s); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代理模式]]></title>
      <url>%2F20170803%2FDesign_pattern%2F15_proxy%2F</url>
      <content type="text"><![CDATA[代理模式介绍代理模式为其他对象提供一种代理以控制对这个对象的访问。（结构型模式）代理模式提供三种角色： 抽象角色：声明真实对象和代理对象的共同接口。 代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。代理模式对外部提供统一的接口方法，而代理类在接口中实现对真实类的附加操作行为，从而可以在不影响外部调用情况下，进行系统扩展。 分类静态代理静态代理就是我们自己静态定义的代理类，例如我们要进行图片加载的时候，可以通过一个代理类减少图片对象加载的内存占用： DEMO图片接口12345678package factory.pattern.proxy.demo1;/** * Created by FK on 2017/8/3. */public interface Image &#123; void dispalay();&#125; 接口实体类 12345678910111213141516171819202122package factory.pattern.proxy.demo1;/** * Created by FK on 2017/8/3. */public class RealImage implements Image &#123; private String fileName; public RealImage(String fileName) &#123; this.fileName = fileName; loadFormDisk(fileName); &#125; private void loadFormDisk(String fileName) &#123; System.out.println(&quot;Loading &quot; + fileName); &#125; @Override public void dispalay() &#123; System.out.println(&quot;Displaying &quot; + fileName); &#125;&#125; 123456789101112131415161718192021package factory.pattern.proxy.demo1;/** * Created by FK on 2017/8/3. */public class ProxyImage implements Image &#123; private RealImage realImage; private String fileNmme; public ProxyImage(String fileNmme) &#123; this.fileNmme = fileNmme; &#125; @Override public void dispalay() &#123; if( realImage == null)&#123; realImage = new RealImage(fileNmme); &#125; realImage.dispalay(); &#125;&#125; 测试12345678910111213package factory.pattern.proxy.demo1;/** * Created by FK on 2017/8/3. */public class Test &#123; public static void main(String[] args) &#123; Image image = new ProxyImage(&quot;test.jpg&quot;); image.dispalay(); System.out.println(); image.dispalay(); &#125;&#125; 动态代理动态代理不需要实现接口，是利用JDK的API来实现代理对象的生成，所以动态代理也是JDK代理。 JDK中生成代理对象的API 代理类所在包:java.lang.reflect.Proxy JDK实现代理只需要使用newProxyInstance方法,但是该方法需要接收三个参数,完整的写法是:12&gt; static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )&gt; 注意该方法是在Proxy类中是静态方法,且接收的三个参数依次为: ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的 Class&lt;?&gt;[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型 InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入 DEMO12345678910111213141516171819202122232425262728package factory.pattern.proxy.demo2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by FK on 2017/8/4. */public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxyInstance()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object returnValue = method.invoke(target, args); return returnValue; &#125; &#125;); &#125;&#125; 测试 1234567891011121314151617package factory.pattern.proxy.demo2;import factory.pattern.proxy.demo1.Image;import factory.pattern.proxy.demo1.RealImage;/** * Created by FK on 2017/8/4. */public class Test &#123; public static void main(String[] args) &#123; Image image = new RealImage(&quot;test1.jpg&quot;); System.out.println(image.getClass()); Image proxy = (Image) new ProxyFactory(image).getProxyInstance(); System.out.println(proxy.getClass()); proxy.dispalay(); &#125;&#125; 应用场合远程代理就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在不同地址空间的事实。 虚拟代理根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。 html网页加载的时候图片是下载之后才能看到，未打开的图片框只存放了真实图片的路径和尺寸。 安全代理安全代理用来控制真实对象访问时的权限。 智能指引当调用真实的对象时，代理处理另外一些事。 计算真是对象的引用次数，当该对象没有引用时，可以自动释放它；或当第一次引用一个持久化对象，将它装载如内存。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[享元模式]]></title>
      <url>%2F20170801%2FDesign_pattern%2F14_flyweight%2F</url>
      <content type="text"><![CDATA[享元模式介绍享元模式使用共享来避免大量拥有相同内容对象的开销，避免内存的损耗。享元对象能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态是存储在享元对象内部的，不会随环境的改变而有所不同（内蕴状态可以共享）。外蕴状态是随环境的改变而改变的，不可以共享，外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。 优点 大幅度地降低内存中对象的数量 缺点 使得系统更加复杂 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长 结构(涉及角色) Flyweight：抽象享元角色，规定具体享元角色要实现的方法。 ConcreteFlyweight：具体享元角色，实现抽象享元规定的接口。 FlyweightFactory：享元工厂角色，负责创建和管理享元角色。 DEMO抽象享元角色，抽象享元中接受一个参数state，state是外蕴状态，由外部传入的不可被共享。 12345678package factory.pattern.flyweight;/** * Created by FK on 2017/8/1. */public interface FlyWeight &#123; public void operation(String state);&#125; 具体享元角色，内部intrinsticState是内蕴状态，内蕴状态在被对象创建后就不会在改变了。 123456789101112131415161718package factory.pattern.flyweight;/** * Created by FK on 2017/8/1. */public class ConcreteFlyWeight implements FlyWeight &#123; private Character intrinsicState = null; public ConcreteFlyWeight(Character intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; @Override public void operation(String state) &#123; System.out.println(&quot;Intrinsic State = &quot; + this.intrinsicState); System.out.println(&quot;Extrinsic State = &quot; + state); &#125;&#125; 享元工厂类（客户端不可以直接将具体享元类实例化， 必须通过一个工厂对象得到享元对象） 123456789101112131415161718192021222324252627package factory.pattern.flyweight;import java.util.HashMap;import java.util.Map;/** * Created by FK on 2017/8/1. */public class FlyWeightFactory &#123; private Map&lt;Character, FlyWeight&gt; files = new HashMap&lt;&gt;(); //享元工厂在系统中只有一个，可以使用单利模式来获取 private static FlyWeightFactory flyWeightFactory = new FlyWeightFactory(); private FlyWeightFactory()&#123;&#125; public static FlyWeightFactory getInstance()&#123; return flyWeightFactory; &#125; public FlyWeight factory(Character state)&#123; FlyWeight fly = files.get(state); if(fly == null)&#123; fly = new ConcreteFlyWeight(state); files.put(state, fly); &#125; return fly; &#125;&#125; 测试：1234567891011121314151617181920package factory.pattern.flyweight;/** * Created by FK on 2017/8/1. */public class Test &#123; public static void main(String[] args) &#123; FlyWeightFactory factory = FlyWeightFactory.getInstance(); FlyWeight fly = factory.factory(new Character(&apos;a&apos;)); fly.operation(&quot;first call&quot;); fly = factory.factory(new Character(&apos;b&apos;)); fly.operation(&quot;Second Call&quot;); fly = factory.factory(new Character(&apos;a&apos;)); fly.operation(&quot;Third Call&quot;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[外观模式]]></title>
      <url>%2F20170801%2FDesign_pattern%2F13_facede%2F</url>
      <content type="text"><![CDATA[外观模式介绍为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。就像下图，facade把众多子系统中通过一个接口统一起来： 适用场景 设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。 优点 实现了子系统与客户端之间的松耦合关系。 客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。 提高了安全性。 DEMO子系统：1234567891011121314151617181920212223242526272829303132333435363738394041424344package factory.pattern.facade;/** * Created by FK on 2017/8/1. */public interface Shape &#123; void draw();&#125;package factory.pattern.facade;/** * Created by FK on 2017/8/1. */public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Circle::draw()&quot;); &#125;&#125;package factory.pattern.facade;/** * Created by FK on 2017/8/1. */public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Rectangle::draw()&quot;); &#125;&#125;package factory.pattern.facade;/** * Created by FK on 2017/8/1. */public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Square::draw()&quot;); &#125;&#125; facade :12345678910111213141516171819202122232425262728package factory.pattern.facade;/** * Created by FK on 2017/8/1. */public class ShapeFacade &#123; private Shape circle; private Shape rectangle; private Shape square; public ShapeFacade() &#123; circle = new Circle(); rectangle = new Rectangle(); square = new Square(); &#125; public void drawCircle()&#123; circle.draw(); &#125; public void drawRectangle()&#123; rectangle.draw(); &#125; public void drawSquare()&#123; square.draw(); &#125;&#125; 测试类：1234567891011121314package factory.pattern.facade;/** * Created by FK on 2017/8/1. */public class FacadeTest &#123; public static void main(String[] args) &#123; ShapeFacade shapeFacade = new ShapeFacade(); shapeFacade.drawCircle(); shapeFacade.drawRectangle(); shapeFacade.drawSquare(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[装饰器模式]]></title>
      <url>%2F20170801%2FDesign_pattern%2F12_decorator%2F</url>
      <content type="text"><![CDATA[装饰器模式介绍装饰器模式允许向一个现有的对象添加新功能，同时又不改变其结构。（结构型模式）这种形式在没有原类文件和使用继承的情况下动态的扩展了一个对象的功能。类的继承是在编译是时候增加的功能，而装饰器模式在运行时增加的功能 装饰器模式构成 Component : 组件对象接口，可以给这些对象动态添加职责 ConcreteComponent ： 具体的组件对象，实现了组件接口。这个对象通常是被装饰器修饰的原始对象，可以给这个对象添加职责。 Decorate : 所有装饰器的父类，需要定义一个与组件接口一直的接口（实现装饰器的复用），并持有component对象，这个对象就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。 ConcreteDecorator：具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。 DEMOComponent 12345678package factory.pattern.Decorator;/** * Created by FK on 2017/8/1. */public interface Shape &#123; void draw();&#125; ConcreteComponent 1234567891011121314151617181920212223package factory.pattern.Decorator;/** * Created by FK on 2017/8/1. */public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape : Circle&quot;); &#125;&#125;package factory.pattern.Decorator;/** * Created by FK on 2017/8/1. */public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Shape : Rectangle&quot;); &#125;&#125; Decorate 1234567891011121314151617package factory.pattern.Decorator;/** * Created by FK on 2017/8/1. */public abstract class ShapeDecorator implements Shape &#123; protected Shape decoratorShape; public ShapeDecorator(Shape decoratorShape) &#123; this.decoratorShape = decoratorShape; &#125; public void draw()&#123; decoratorShape.draw(); &#125;&#125; ConcreteDecorator 123456789101112131415161718192021222324package factory.pattern.Decorator;import java.util.ArrayList;import java.util.List;/** * Created by FK on 2017/8/1. */public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratorShape) &#123; super(decoratorShape); &#125; @Override public void draw() &#123; decoratorShape.draw(); setRedBorder(decoratorShape); &#125; public void setRedBorder(Shape redBorder) &#123; System.out.println(&quot;Border Color : Red&quot;); List&lt;String&gt; list = new ArrayList&lt;&gt;(); &#125;&#125; TEST 12345678910111213141516171819package factory.pattern.Decorator;/** * Created by FK on 2017/8/1. */public class DecoratorPatternDemo &#123; public static void main(String[] args) &#123; Shape shape = new Circle(); Shape redCircle = new RedShapeDecorator(new Circle()); Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(&quot;Circle with normal border&quot;); shape.draw(); System.out.println(&quot;\nCircle of red border&quot;); redCircle.draw(); System.out.println(&quot;\nRectangle of red border&quot;); redRectangle.draw(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[组合模式]]></title>
      <url>%2F20170729%2FDesign_pattern%2F11_composite%2F</url>
      <content type="text"><![CDATA[组合模式介绍组合模式将对象组合成树形结构表示“部分-整体”的层次结构，组合模式使用户对单个对象和组合对象的使用具有一致性。（结构型）就像文件系统一样，文件由目录和文件组成，每个目录都可以装载目录，目录的内容既可以是文件，也可以是目录。计算机的文件系统就是以递归结构来组织的，这种情景就适用于组合模式。 使用场景和涉及的角色适用性 你想表示对象的部分-整体层次结构 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 涉及角色 Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。 Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。 DEMO123456789101112131415161718192021222324252627282930package factory.pattern.composite.test;/** * Created by FK on 2017/7/30. */public abstract class Component &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Component()&#123;&#125; public Component(String name) &#123; this.name = name; &#125; protected abstract void add(Component company); protected abstract void remove(Component company); protected abstract void display(int depth);&#125; 枝节点行为，具体目录类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package factory.pattern.composite.test;import java.util.ArrayList;import java.util.List;/** * Created by FK on 2017/7/30. */public class CatalogComponent extends Component &#123; List&lt;Component&gt; list; public List&lt;Component&gt; getList() &#123; return list; &#125; public void setList(List&lt;Component&gt; list) &#123; this.list = list; &#125; public CatalogComponent() &#123; list = new ArrayList&lt;&gt;(); &#125; public CatalogComponent(String name) &#123; super(name); list = new ArrayList&lt;&gt;(); &#125; @Override protected void add(Component company) &#123; list.add(company); &#125; @Override protected void remove(Component company) &#123; list.remove(company); &#125; @Override protected void display(int depth) &#123; StringBuffer sb = new StringBuffer(); for(int i=0;i&lt;depth;i++)&#123; sb.append(&quot;-&quot;); &#125; System.out.println(new String(sb) + this.getName()); for(Component c : list)&#123; c.display(depth + 2); &#125; &#125;&#125; 叶子结点对象,文件123456789101112131415161718192021222324252627282930313233package factory.pattern.composite.test;/** * Created by FK on 2017/7/30. */public class Leaf extends Component &#123; public Leaf() &#123; super(); &#125; public Leaf(String name) &#123; super(name); &#125; @Override protected void add(Component company) &#123; &#125; @Override protected void remove(Component company) &#123; &#125; @Override protected void display(int depth) &#123; StringBuffer sb = new StringBuffer(); for(int i=0;i&lt;depth;i++)&#123; sb.append(&quot;-&quot;); &#125; System.out.println(new String(sb) + this.getName()); &#125;&#125; 测试类1234567891011121314151617package factory.pattern.composite.test;/** * Created by FK on 2017/7/30. */public class Test &#123; public static void main(String[] args) &#123; Component c = new CatalogComponent(); Component c1 = new CatalogComponent(&quot;一级目录1&quot;); Component c2 = new CatalogComponent(&quot;二级目录1&quot;); c2.add(new Leaf(&quot;文件1&quot;)); c1.add(c2); c.add(c1); c.add(new CatalogComponent(&quot;一级目录2&quot;)); c.display(0); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[过滤器模式]]></title>
      <url>%2F20170727%2FDesign_pattern%2F10_filter%2F</url>
      <content type="text"><![CDATA[过滤器模式介绍过滤器模式允许开发者用不同的标准过滤一组对象。（结构型模式）使用过滤器模式可以很方便的进行扩展，单独一个过滤器的执行是独立的，不依赖其他过滤器。 DEMO例如，一个Person类有姓名、性别、婚姻状况属性 ：1234567891011121314151617181920212223242526272829303132333435363738394041424344package factory.pattern.filter;/** * Created by fk5431 on 7/27/17. */public class Person &#123; private String name; private String sex; private String marital; public Person(String name, String sex, String marital)&#123; this.name = name; this.sex = sex; this.marital = marital; &#125; public String getName() &#123; return name; &#125; public String getSex() &#123; return sex; &#125; public String getMarital() &#123; return marital; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setMarital(String marital) &#123; this.marital = marital; &#125; @Override public String toString() &#123; return &quot;Persion name : &quot; + this.name + &quot; sex &quot; + this.sex + &quot; marital &quot; + this.marital; &#125;&#125; 建立一个过滤器标准12345678910package factory.pattern.filter;import java.util.List;/** * Created by fk5431 on 7/27/17. */public interface Filter &#123; List&lt;Person&gt; filter(List&lt;Person&gt; persions);&#125; 实现男性过滤和未婚过滤1234567891011121314151617181920212223242526272829303132333435363738394041package factory.pattern.filter;import java.util.ArrayList;import java.util.List;/** * Created by fk5431 on 7/27/17. */public class MaleFilter implements Filter &#123; @Override public List&lt;Person&gt; filter(List&lt;Person&gt; persions) &#123; List&lt;Person&gt; result = new ArrayList&lt;Person&gt;(); for(Person p : persions)&#123; if (&quot;MALE&quot;.equalsIgnoreCase(p.getSex()))&#123; result.add(p); &#125; &#125; return result; &#125;&#125;package factory.pattern.filter;import java.util.ArrayList;import java.util.List;/** * Created by fk5431 on 7/27/17. */public class SingleFilter implements Filter &#123; @Override public List&lt;Person&gt; filter(List&lt;Person&gt; persions) &#123; List&lt;Person&gt; result = new ArrayList&lt;Person&gt;(); for(Person p : persions)&#123; if (&quot;SINGLE&quot;.equalsIgnoreCase(p.getMarital()))&#123; result.add(p); &#125; &#125; return result; &#125;&#125; 过滤器可以进行叠加和其他操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package factory.pattern.filter;import java.util.List;/** * Created by fk5431 on 7/27/17. */public class FilterAnd implements Filter &#123; private Filter filter; private Filter otherfilter; public FilterAnd(Filter filter, Filter otherfilter)&#123; this.filter = filter; this.otherfilter = otherfilter; &#125; @Override public List&lt;Person&gt; filter(List&lt;Person&gt; persions) &#123; List&lt;Person&gt; tmpList = filter.filter(persions); return otherfilter.filter(tmpList); &#125;&#125;package factory.pattern.filter;import java.util.List;/** * Created by fk5431 on 7/27/17. */public class FilterOr implements Filter &#123; private Filter filter; private Filter otherfilter; public FilterOr(Filter filter, Filter otherfilter)&#123; this.filter = filter; this.otherfilter = otherfilter; &#125; @Override public List&lt;Person&gt; filter(List&lt;Person&gt; persions) &#123; List&lt;Person&gt; tmpList = filter.filter(persions); List&lt;Person&gt; tmpList2 = otherfilter.filter(persions); for(Person p : tmpList2)&#123; if(!tmpList.contains(p))&#123; tmpList.add(p); &#125; &#125; return tmpList; &#125;&#125; 最后进行测试1234567891011121314151617181920212223242526272829303132333435363738394041424344package factory.pattern.filter;import java.util.ArrayList;import java.util.List;/** * Created by fk5431 on 7/27/17. */public class Test &#123; public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;&gt;(); persons.add(new Person(&quot;霍一&quot;, &quot;FEMALE&quot;, &quot;MARRIED&quot;)); persons.add(new Person(&quot;邓二&quot;, &quot;MALE&quot;, &quot;MARRIED&quot;)); persons.add(new Person(&quot;张三&quot;, &quot;MALE&quot;, &quot;SINGLE&quot;)); persons.add(new Person(&quot;李四&quot;, &quot;FEMALE&quot;, &quot;MARRIED&quot;)); persons.add(new Person(&quot;王五&quot;, &quot;MALE&quot;, &quot;SINGLE&quot;)); persons.add(new Person(&quot;赵六&quot;, &quot;FEMALE&quot;, &quot;SINGLE&quot;)); persons.add(new Person(&quot;孙七&quot;, &quot;MALE&quot;, &quot;SINGLE&quot;)); persons.add(new Person(&quot;罗八&quot;, &quot;MALE&quot;, &quot;MARRIED&quot;)); persons.add(new Person(&quot;刘九&quot;, &quot;FEMALE&quot;, &quot;SINGLE&quot;)); persons.add(new Person(&quot;史十&quot;, &quot;FEMALE&quot;, &quot;SINGLE&quot;)); List&lt;Person&gt; malePerson = new MaleFilter().filter(persons); for(Person p : malePerson)&#123; System.out.println(p.toString()); &#125; System.out.println(); System.out.println(); System.out.println(); System.out.println(); List&lt;Person&gt; singlePerson = new MaleFilter().filter(persons); for(Person p : singlePerson)&#123; System.out.println(p.toString()); &#125; System.out.println(); System.out.println(); System.out.println(); System.out.println(); List&lt;Person&gt; singleAndMalePerson = new FilterAnd(new MaleFilter(), new SingleFilter()).filter(persons); for(Person p : singleAndMalePerson)&#123; System.out.println(p.toString()); &#125; &#125;&#125; 输出结果如下： Persion name : 邓二 sex MALE marital MARRIED Persion name : 张三 sex MALE marital SINGLE Persion name : 王五 sex MALE marital SINGLE Persion name : 孙七 sex MALE marital SINGLE Persion name : 罗八 sex MALE marital MARRIED Persion name : 邓二 sex MALE marital MARRIED Persion name : 张三 sex MALE marital SINGLE Persion name : 王五 sex MALE marital SINGLE Persion name : 孙七 sex MALE marital SINGLE Persion name : 罗八 sex MALE marital MARRIED Persion name : 张三 sex MALE marital SINGLE Persion name : 王五 sex MALE marital SINGLE Persion name : 孙七 sex MALE marital SINGLE]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[桥接模式]]></title>
      <url>%2F20170726%2FDesign_pattern%2F9_Bridge%2F</url>
      <content type="text"><![CDATA[桥接模式介绍桥接适用于把抽象化与实现化解耦，使得二者可以独立变化。（结构型模式）用来解决两个或者多个纬度的变化，使用桥接模式可以降低复杂度。将两个角色之间的继承关系改为聚合关系，这样两者可以独立的变化。 例子就像大话设计模式中讲的一样，每个手机都有其对应的功能（软件），而这些功能在不同手机上可能不兼容，那么列出一个手机品牌和其对应的部分功能的结构图如下：但是这样的话，不管要增加一个手机品牌还是要增加一个软件，操作都会很复杂。因此用桥接模式把这这两个维度之间的继承关系改为聚合关系会使这个问题变得简单，聚合关系的结构图如下： DEMO手机软件抽象类12345678package factory.pattern.bridge;/** * Created by FK on 2017/7/26. */public abstract class HandSetSoft &#123; public abstract void run();&#125; 手机游戏1234567891011package factory.pattern.bridge;/** * Created by FK on 2017/7/26. */public class HandSetGame extends HandSetSoft &#123; @Override public void run() &#123; System.out.println(&quot;运行手机游戏&quot;); &#125;&#125; 手机通讯录1234567891011package factory.pattern.bridge;/** * Created by FK on 2017/7/26. */public class HandSetAdressList extends HandSetSoft &#123; @Override public void run() &#123; System.out.println(&quot;运行手机通讯录&quot;); &#125;&#125; 手机品牌1234567891011121314package factory.pattern.bridge;/** * Created by FK on 2017/7/26. */public abstract class HandSetBrand &#123; HandSetSoft handSetSoft; public void setHandSetSoft(HandSetSoft handSetSoft)&#123; this.handSetSoft = handSetSoft; &#125; public abstract void run();&#125; 手机品牌N1234567891011package factory.pattern.bridge;/** * Created by FK on 2017/7/26. */public class HandSetBrandN extends HandSetBrand &#123; @Override public void run() &#123; handSetSoft.run(); &#125;&#125; 手机品牌A1234567891011package factory.pattern.bridge;/** * Created by FK on 2017/7/26. */public class HandSetBrandA extends HandSetBrand &#123; @Override public void run() &#123; handSetSoft.run(); &#125;&#125; 测试类1234567891011121314151617181920package factory.pattern.bridge;/** * Created by FK on 2017/7/26. */public class Test &#123; public static void main(String[] args) &#123; HandSetBrand hb ; hb = new HandSetBrandA(); hb.setHandSetSoft(new HandSetGame()); hb.run(); hb.setHandSetSoft(new HandSetAdressList()); hb.run(); hb = new HandSetBrandN(); hb.setHandSetSoft(new HandSetGame()); hb.run(); hb.setHandSetSoft(new HandSetAdressList()); hb.run(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[适配器模式]]></title>
      <url>%2F20170725%2FDesign_pattern%2F8_Adapter%2F</url>
      <content type="text"><![CDATA[适配器模式介绍适配器模式讲一个类的接口转换为被期望用到的另一个接口,使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作.(结构型模式) 适配器模式中的角色一般适配器模式中有以下三个角色: 目标接口(Target) : 客户期待的接口. 需要适配的类(Adaptee) : 需要适配的类. 适配器(Adapter) : 包装一个需要适配的对象,吧原接口转换为目标接口. 优点 通过适配器,客户端调用同一接口. 复用的现存的类 将目标类和适配者类解耦 缺点过多的使用适配器，会让系统非常零乱，不易整体进行把握. DEMO目标接口12345678910package factory.pattern.Adapter;/** * Created by fk5431 on 7/25/17. */public class Target &#123; public void Request()&#123; System.out.println(&quot;普通请求&quot;); &#125;&#125; 需要适配的类12345678910package factory.pattern.Adapter;/** * Created by fk5431 on 7/25/17. */public class Adaptee &#123; public void SpecificRequest()&#123; System.out.println(&quot;特殊请求&quot;); &#125;&#125; 适配器12345678910111213package factory.pattern.Adapter;/** * Created by fk5431 on 7/25/17. */public class Adapter extends Target &#123; private Adaptee adaptee = new Adaptee(); @Override public void Request() &#123; adaptee.SpecificRequest(); &#125;&#125; 测试1234567891011package factory.pattern.Adapter; /** * Created by fk5431 on 7/25/17. */ public class Test &#123; public static void main(String[] args) &#123; Target target = new Adapter(); target.Request(); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原型模式]]></title>
      <url>%2F20170724%2FDesign_pattern%2F7_Prototype%2F</url>
      <content type="text"><![CDATA[原型模式介绍用原型实例制定创建对象的种类，并通过拷贝这些原型创建新的对象。（创建型模式）原型模式比较简单的一种模式，实现一个接口就完成了原型模式。一般原型模式很少单独出现，会与其他模式混用。 适用场景使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 注意事项 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。 深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。如果有数组等等其他对象要进行深拷贝时候：12345678910111213public class Prototype implements Cloneable &#123; private ArrayList list = new ArrayList(); public Prototype clone()&#123; Prototype prototype = null; try&#123; prototype = (Prototype)super.clone(); prototype.list = (ArrayList) this.list.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return prototype; &#125; &#125; DEMO12345678910111213141516package factory.pattern.Proto;/** * Created by FK on 2017/7/25. */public class Prototype implements Cloneable&#123; public Prototype clone()&#123; Prototype prototype = null; try &#123; prototype = (Prototype) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return prototype; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[建造者模式]]></title>
      <url>%2F20170716%2FDesign_pattern%2F6_builder%2F</url>
      <content type="text"><![CDATA[建造者模式定义将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。(创建型模式) 使用场景1 创建一些复杂的对象时,这些对象的内部组成间的构建顺序是稳定的,但是对象的内部组成构件面临着复杂的变化。2 要创建的复杂对象的算法,独立于该对象的组成部分,也独立与组成部分的装配方法时。 优点: 使用建造者模式可以让客户端不知道产品内部的组成细节. 具体的建造类之间是相互独立的,对系统的扩展是非常有利的. 由于具体的建造者是独立的,因此可以对建造过程逐步细化,而对其他的模块没有任何影响. 建造者模式一般包含的角色 builder: 给出一个抽象接口,以规范产品对象的各个组成成分的建造.这个接口规定要实现负责对象的哪些部分的创建,不涉及具体对象部件的创建, ConcreteBuilder: 实现Builder接口,针对不同的商业逻辑,具体化复杂对象的各部分的创建.在建造过程完成后,提供产品实例. Director: 调用具体建造者来创建复杂对象的各个部分,在指导者中不涉及具体产品的信息,只负责保证对象各部分完整创建或按某顺序创建. Product: 要创建的负责对象. Demo如果要创建一个小人,肯定要创建人的头,身体,手,脚,现在系统将人分为胖人和瘦人,那么设计如下: 首先是Persion12345678910111213141516171819202122package factory.pattern.Builder;import java.util.ArrayList;import java.util.List;/** * Created by fk5431 on 7/24/17. */public class Persion &#123; private List&lt;String&gt; parts = new ArrayList&lt;String&gt;(); public void Add(String part)&#123; parts.add(part); &#125; public void Show()&#123; for(String part : parts)&#123; System.out.println(part); &#125; &#125;&#125; 然后是Builder123456789101112package factory.pattern.Builder; /** * Created by fk5431 on 7/24/17. */ public interface Builder &#123; void BuildHead(); void BuildBody(); void BuildHand(); void BuildFeet(); Persion getResult(); &#125; 然后瘦人胖人类分别实现接口123456789101112131415161718192021222324252627282930package factory.pattern.Builder;/** * Created by fk5431 on 7/24/17. */public class FatPersonBuilder implements Builder &#123; private Persion product; public FatPersonBuilder()&#123; product = new Persion(); &#125; public void BuildHead() &#123; product.Add(&quot;胖人头&quot;); &#125; public void BuildBody() &#123; product.Add(&quot;胖人身体&quot;); &#125; public void BuildHand() &#123; product.Add(&quot;胖人手&quot;); &#125; public void BuildFeet() &#123; product.Add(&quot;胖人脚&quot;); &#125; public Persion getResult() &#123; return product; &#125;&#125; 123456789101112131415161718192021222324252627282930package factory.pattern.Builder;/** * Created by fk5431 on 7/24/17. */public class ThinPersonBuilder implements Builder &#123; Persion product; public ThinPersonBuilder()&#123; product = new Persion(); &#125; public void BuildHead() &#123; product.Add(&quot;瘦人头&quot;); &#125; public void BuildBody() &#123; product.Add(&quot;瘦人身体&quot;); &#125; public void BuildHand() &#123; product.Add(&quot;瘦人手&quot;); &#125; public void BuildFeet() &#123; product.Add(&quot;瘦人脚&quot;); &#125; public Persion getResult() &#123; return product; &#125;&#125; 然后是指导者1234567891011121314package factory.pattern.Builder;/** * Created by fk5431 on 7/24/17. */public class Director &#123; public Persion Persion(Builder builder)&#123; builder.BuildBody(); builder.BuildFeet(); builder.BuildHand(); builder.BuildHead(); return builder.getResult(); &#125;&#125; 最后测试一下12345678public class Test &#123; public static void main(String[] args) &#123; Director d = new Director(); Persion p = d.Persion(new ThinPersonBuilder()); p.Show(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[双重检查锁定]]></title>
      <url>%2F20170620%2FDesign_pattern%2F5_double-checked-locking%2F</url>
      <content type="text"><![CDATA[双重检查锁定产生原因在写Java程序的时候,有时候会推迟高开销对象的初始化,在使用的时候在进行初始化,达到lazy loading的效果.但是进行延迟初始化的时候可能会产生很多问题(多线程环境),例如:12345678910public class UnsafeLazyLoading &#123; private static UnsafeLazyLoading unsafeLazyLoading; private UnsafeLazyLoading ()&#123;&#125; public static UnsafeLazyLoading getInstance()&#123; if( unsafeLazyLoading == null)&#123; //sign 1 unsafeLazyLoading = new UnsafeLazyLoading(); //sing 2 &#125; return unsafeLazyLoading; &#125;&#125; 就比如简单的单例模式要获取唯一的实例,如果在多线程环境下如果线程A运行到 sign 1标识的行,此时线程B运行到 sing 2标识的行,线程A就会看到需要的实例还没有被初始化,就会产生问题. 处理这个可以加同步锁,代码如下:12345678910public class UnsafeLazyLoading &#123; private static UnsafeLazyLoading unsafeLazyLoading; private UnsafeLazyLoading ()&#123;&#125; public synchronized static UnsafeLazyLoading getInstance()&#123; if( unsafeLazyLoading == null)&#123; //sign 1 unsafeLazyLoading = new UnsafeLazyLoading(); //sing 2 &#125; return unsafeLazyLoading; &#125;&#125; 但是每次在获取实例的时候都会进入同步锁,会严重影响系统的性能.所以通过双重检查锁定来实现延迟初始化,代码如下:123456789101112131415public class UnsafeLazyLoading &#123; private static UnsafeLazyLoading unsafeLazyLoading; private UnsafeLazyLoading ()&#123;&#125; public static UnsafeLazyLoading getInstance()&#123; if( unsafeLazyLoading == null)&#123; //sign 1 synchronized (UnsafeLazyLoading.class)&#123; if( unsafeLazyLoading == null)&#123; unsafeLazyLoading = new UnsafeLazyLoading(); &#125; &#125; &#125; return unsafeLazyLoading; &#125;&#125; 上面这种方法看起很好 在多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。 在对象创建好之后，执行getInstance()将不需要获取锁，直接返回已创建好的对象。 但是执行到 sing1 标识的地方的时候,线程有可能unsafeLazyLoading不为空的时候,但是unsafeLazyloading引用的对象还有可能没有完成初始化的过程. ###问题根源在上述代码执行到 unsafelazyloading = new UnsafeLazyLoading(); 的时候,此时创建一个对象可分解为以下三步:1234&gt; memory = allocate(); //1：分配对象的内存空间&gt; ctorInstance(memory); //2：初始化对象&gt; instance = memory; //3：设置instance指向刚分配的内存地址 &gt; 上面三行伪代码中的2和3之间，可能会被重排序（在一些JIT编译器上，这种重排序是真实发生的，详情见参考文献1的“Out-of-order writes”部分）。2和3之间重排序之后的执行时序如下：12345&gt; memory = allocate(); //1：分配对象的内存空间&gt; instance = memory; //3：设置instance指向刚分配的内存地址&gt; //注意，此时对象还没有被初始化！&gt; ctorInstance(memory); //2：初始化对象&gt; 根据《The Java Language Specification, Java SE 7 Edition》（后文简称为java语言规范），所有线程在执行java程序时必须要遵守intra-thread semantics。intra-thread semantics保证重排序不会改变单线程内的程序执行结果。换句话来说，intra-thread semantics允许那些在单线程内，不会改变单线程程序执行结果的重排序。上面三行伪代码的2和3之间虽然被重排序了，但这个重排序并不会违反intra-thread semantics。这个重排序在没有改变单线程程序的执行结果的前提下，可以提高程序的执行性能。为了更好的理解intra-thread semantics，请看下面的示意图（假设一个线程A在构造对象后，立即访问这个对象）：只要保证2排在4的前面，即使2和3之间重排序了，也不会违反intra-thread semantics。但是在多线程执行并发的时候示意图如下:由于单线程内要遵守intra-thread semantics，从而能保证A线程的程序执行结果不会被改变。但是当线程A和B按上图的时序执行时，B线程将看到一个还没有被初始化的对象。所以在双重检查锁定代码的（unsafeLazyLoading = new UnsafeLazyLoading(); ）如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化！下面是这个场景的具体执行时序： 时间 线程A 线程B t1 A1：分配对象的内存空间 t2 A3：设置instance指向内存空间 t3 B1：判断instance是否为空 t4 B2：由于instance不为null，线程B将访问instance引用的对象 t5 A2：初始化对象 t6 A4：访问instance引用的对象 这里A2和A3虽然重排序了，但java内存模型的intra-thread semantics将确保A2一定会排在A4前面执行。因此线程A的intra-thread semantics没有改变。但A2和A3的重排序，将导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象。 在知晓了问题发生的根源之后，我们可以想出两个办法来实现线程安全的延迟初始化： 不允许2和3重排序； 允许2和3重排序，但不允许其他线程“看到”这个重排序。 以上引用内容来自 http://ifeve.com/double-checked-locking-with-delay-initialization/ 解决方案基于volatile的双重检定只需要把要获取的实例unsafeLazyLoading声明为volatile就可以,如下:123456789101112131415public class UnsafeLazyLoading &#123; private volatile static UnsafeLazyLoading unsafeLazyLoading; private UnsafeLazyLoading ()&#123;&#125; public static UnsafeLazyLoading getInstance()&#123; if( unsafeLazyLoading == null)&#123; //sign 1 synchronized (UnsafeLazyLoading.class)&#123; if( unsafeLazyLoading == null)&#123; unsafeLazyLoading = new UnsafeLazyLoading(); &#125; &#125; &#125; return unsafeLazyLoading; &#125;&#125; 当声明对象的引用为volatile后，上述说到的2和3之间的重排序，在多线程环境中将会被禁止。 基于类初始化 JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。因此就可以采用静态内部类的形式实现延迟加载的效果,像上一篇文章最后的代码一样.1234567891011121314package factory.pattern.singleton;/** * Created by fk5431 on 6/19/17. */public class SingletonStaticClass &#123; //静态内部类 private static class SingletonHodler&#123; private static final SingletonStaticClass INSTANCE = new SingletonStaticClass(); &#125; private SingletonStaticClass()&#123;&#125; public static final SingletonStaticClass getInstance()&#123; return SingletonHodler.INSTANCE; &#125;&#125; 这样虽然允许了上述的2,3之间的重排序,但是非构造线程无法被重排序所影响.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>%2F20170619%2FDesign_pattern%2F4_singleton-pattern%2F</url>
      <content type="text"><![CDATA[单例模式定义一个类有且仅有一个实例，并且自行实例化向整个系统提供。(创建型模式)设计模式中比较简单的几种之一,单例模式就是让一个类在系统运行过程中只会产生唯一的一个实例,单例模式主要: 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 使用场景 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 有状态的工具类对象。 频繁访问数据库或文件的对象。 单例模式的实现单例模式的实现一般根据实例化对象时的不同分为懒汉式和饿汉式. 懒汉式典型实现1234567891011121314package factory.pattern.singleton;/** * Created by fk5431 on 6/19/17. */public class SingletonLazy &#123; private static SingletonLazy singletonLazy; private SingletonLazy ()&#123;&#125; public static SingletonLazy getInstance()&#123; if( singletonLazy == null)&#123; singletonLazy = new SingletonLazy(); &#125; return singletonLazy; &#125;&#125; 懒汉式的模式就是在需要进行实例化的时候在进行实例化,这种方式在多线程的时候是有问题的,会有线程安全问题. 懒汉式线程安全形式1234567891011121314package factory.pattern.singleton;/** * Created by fk5431 on 6/19/17. */public class SingletonLazeSafe &#123; private static SingletonLazeSafe singletonLazeSafe; private SingletonLazeSafe()&#123;&#125; public static synchronized SingletonLazeSafe getInstance()&#123; if(singletonLazeSafe == null)&#123; singletonLazeSafe = new SingletonLazeSafe(); &#125; return singletonLazeSafe; &#125;&#125; 懒汉式的线程安全模式在进入获取实例方法时候就会加synchronize,可以保证线程安全获取唯一的实例,但是如果该方法调用过多会有性能方面的影响. 饿汉式1234567891011package factory.pattern.singleton;/** * Created by fk5431 on 6/19/17. */public class SingletonHungary &#123; private static SingletonHungary singletonHungary = new SingletonHungary(); private SingletonHungary()&#123;&#125; public static SingletonHungary getInstance()&#123; return singletonHungary; &#125;&#125; 饿汉式会在类装载时候就进行实例的初始化,虽然没有了synchronize的效率影响,但是在类加载的时候就进行了初始化一方面浪费了内存,也没有实现lazy loading加载的效果. 双重校验锁123456789101112131415161718package factory.pattern.singleton;/** * Created by fk5431 on 6/19/17. */public class DoubleCheckedLocking &#123; private static DoubleCheckedLocking doubleCheckedLocking; private DoubleCheckedLocking()&#123;&#125; public DoubleCheckedLocking getInstance()&#123; if(doubleCheckedLocking == null)&#123; synchronized (DoubleCheckedLocking.class)&#123; if(doubleCheckedLocking == null)&#123; doubleCheckedLocking = new DoubleCheckedLocking(); &#125; &#125; &#125; return doubleCheckedLocking; &#125;&#125; 这种方式采用了双锁机制,一方面保证了多线程的安全,另一方面还提高了效率.但是看起来是完美,但是实际上这种方式是有缺陷的,是错误的一种.(双重检查锁定的问题下次专门写个文章) 静态内部类1234567891011121314package factory.pattern.singleton;/** * Created by fk5431 on 6/19/17. */public class SingletonStaticClass &#123; //静态内部类 private static class SingletonHodler&#123; private static final SingletonStaticClass INSTANCE = new SingletonStaticClass(); &#125; private SingletonStaticClass()&#123;&#125; public static final SingletonStaticClass getInstance()&#123; return SingletonHodler.INSTANCE; &#125;&#125; 这种方式利用了 classloder 机制来保证初始化 instance 时只有一个线程,但是这个是类装载的时候不一定会进行初始化,只有在调用 getInstance 方法时候才会显示的装载SingletonHodler,然后实例化instance. 枚举的方式123public enum EnumSingleton &#123; INSTANCE;&#125; 枚举的方式最简单，又是线程安全的（默认枚举实例的创建是线程安全的）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抽象工厂模式]]></title>
      <url>%2F20170618%2FDesign_pattern%2F3_abstract-factory-pattern%2F</url>
      <content type="text"><![CDATA[抽象工厂模式介绍为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。（创建型模式） 和工厂模式区别工厂模式提供一个产品的结构，而抽象工厂模式提供多个产品的结构，可以组成一个产品族。 QQ换皮肤可以使用抽象工厂模式 优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。缺点：扩展非常麻烦，需要修改很多代码。 DEMO可以在前一个例子上给图形增加颜色，就相当于一个产品族了： 先创建一个图形和颜色的接口类： 12345678package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public interface Color &#123; void fill();&#125; 12345678package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public interface Shape &#123; void draw();&#125; 然后分别实现各自两个类进行测试： 1234567891011package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class Black implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Black : fill()&quot;); &#125;&#125; 1234567891011package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Red : fill()&quot;); &#125;&#125; 1234567891011package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Circle : draw()&quot;); &#125;&#125; 1234567891011package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Rectangle : draw()&quot;); &#125;&#125; 然后实现工厂抽象类： 123456789package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public abstract class AbstractFactory &#123; abstract Color getColorFactory(String color); abstract Shape getShapeFactory(String shape);&#125; 然后扩展工厂抽象类： 12345678910111213141516171819202122232425package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class ShapeFactory extends AbstractFactory &#123; @Override Color getColorFactory(String color) &#123; return null; &#125; @Override Shape getShapeFactory(String shape) &#123; if(shape == null) &#123; return null; &#125; if (&quot;rectangle&quot;.equals(shape))&#123; return new Rectangle(); &#125;else if (&quot;circle&quot;.equals(shape))&#123; return new Circle(); &#125;else &#123; return null; &#125; &#125;&#125; 12345678910111213141516171819202122232425package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class ColorFactory extends AbstractFactory &#123; @Override Color getColorFactory(String color) &#123; if(color == null) &#123; return null; &#125; if(&quot;red&quot;.equals(color))&#123; return new Red(); &#125;else if(&quot;black&quot;.equals(color))&#123; return new Black(); &#125;else &#123; return null; &#125; &#125; @Override Shape getShapeFactory(String shape) &#123; return null; &#125;&#125; 然后写一个工厂创造器：123456789101112131415package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;shape&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;color&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; 最后写一个测试类来试试输出：123456789101112131415161718192021package factory.pattern.abs;/** * Created by FK on 2017/6/18. */public class AbstractFactoryPattern &#123; public static void main(String[] args) &#123; AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;shape&quot;); Shape shape1 = shapeFactory.getShapeFactory(&quot;circle&quot;); shape1.draw(); Shape shape2 = shapeFactory.getShapeFactory(&quot;rectangle&quot;); shape2.draw(); AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;color&quot;); Color color1 = colorFactory.getColorFactory(&quot;red&quot;); color1.fill(); Color color2 = colorFactory.getColorFactory(&quot;black&quot;); color2.fill(); &#125;&#125; 输出如果如下:1234Circle : draw()Rectangle : draw()Red : fill()Black : fill()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式——工厂模式]]></title>
      <url>%2F20170617%2FDesign_pattern%2F2_factory_pattern%2F</url>
      <content type="text"><![CDATA[工厂模式介绍定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。（创建型模式） 使用场景例如orm框架，在选择数据库的时候只需要替换方言和驱动，不需要对已经实现的具体细节进行改动。 优点：使用工厂模式可以屏蔽具体实现，只需要关心接口的调用；在增加一个产品的时候，只需要在工厂类里扩展一个产品就可以。 缺点：每增加产品就必须增加具体实现类和实现工厂，增加了系统复杂性。（如果产品非常非常多，233333） DEMO工厂模式比较简单，就写个最常用的例子：图形。 12345678package factory.pattern;/** * Created by FK on 2017/6/17. */public interface Shape &#123; void draw();&#125; 创建 shape抽象类 1234567891011package factory.pattern;/** * Created by FK on 2017/6/17. */public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Rectangle : draw()&quot;); &#125;&#125; rectangle实现shape方法 123456789101112package factory.pattern;/** * Created by FK on 2017/6/17. */public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Circle : draw()&quot;); &#125;&#125; circle实现shape方法 123456789101112package factory.pattern;/** * Created by FK on 2017/6/17. */public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Square : draw()&quot;); &#125;&#125; square实现shape方法 12345678910111213141516171819202122package factory.pattern;/** * Created by FK on 2017/6/17. */public class ShapeFactory &#123; public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125;&#125; 创建一个工厂，生成基于给传入值的实体类的对象。 12345678910111213141516171819package factory.pattern;/** * Created by FK on 2017/6/17. */public class FactoryPattern &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); Shape circle = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 circle.draw(); Shape rectangle = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 rectangle.draw(); Shape square = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 square.draw(); &#125;&#125; 写个demo来测试下输出是否实现了工厂模式，输出如下：123Circle : draw()Rectangle : draw()Square : draw()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>%2F20170616%2FDesign_pattern%2F1_start%2F</url>
      <content type="text"><![CDATA[设计模式设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。其实就是经过前人反复使用总结使用得出在不同场景有对应的解决方案。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 设计原则开闭原则模块应对扩展开放，对修改关闭，也就是在对程序进行拓展的时候，不要去修改原来的代码，实现热插拔的效果。这样可以使得程序扩展性更好，更易于维护。（主要是使用接口和抽象类实现，例如“抽象工厂模式”） 里氏替换原则任何父类出现的地方，子类一定可以出现，就是用子类替换也一定可以运行。（子类可以扩展父类但不能改变父类的功能）（里氏替换原则可以说继承复用的基础） 依赖倒转原则程序要依赖于抽象接口，不要依赖于具体实现。（开闭原则的基础）针对接口编程，依赖抽象类而不依赖具体类。 接口隔离原则使用多个隔离的接口，比使用单个接口要好。其实就降低程序之间的耦合度，增加系统的可维护性。 最少知道原则（迪米特法则）一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。也是降低类之间的耦合度。 合成复用原则尽量使用合成/聚合的方式，而不是使用继承。某些情景下可以在一个新对象里面使用一些已有的对象达到复用的作用，而不是通过继承的方式，这样如果已有的类要进行改动就不需要对所有的类进行改动了。 设计模式的分类 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。 J2EE模式：MVC 模式、业务代表模式、组合实体模式、数据访问对象模式、前端控制器模式、拦截过滤器模式、服务定位器模式、传输对象模式。 (图片来自菜鸟教程)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入分析ConcurrentHashMap]]></title>
      <url>%2F20170503%2Fjava%2F1_concurrentHashMap%2F</url>
      <content type="text"><![CDATA[HashMap的问题HashMap是不支持并发操作的，多线程情况下HashMap可能会导致死循环的发生，导致CPU占用率达到100%。 Hash表的数据结构HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。如果table[] 大小很小，那么要放入更多的元素的时候，产生的碰撞就会非常频繁，这样会影响Hash表的性能。所以，hash表的容量非常重要，如果有元素要插入时候，如果超过了设定的threshold，那么就必须增大hash表的大小，hash表的每个元素就必须重新被计算一边，也就是rehash。 HashMap的源码12345678910111213141516171819202122232425public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); //计算Hash值 int hash = hash(key); int i = indexFor(hash, table.length); //如果存在值，替换旧值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //增加节点 addEntry(hash, key, value, i); return null;&#125; 上面代码是HashMap进行put一个元素时候的源码。 12345678910void addEntry(int hash, K key, V value, int bucketIndex) &#123; //如果大小大于现在的threshold时候，需要resize if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; 在增加节点时候会判断是否需要rehash操作。 1234567891011121314 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; //新建一个Hash Table Entry[] newTable = new Entry[newCapacity]; //吧旧oldtable 迁移到新的newTable上 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; resize源码会新建个更大的hash表 12345678910111213141516void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; // 从OldTable里摘一个元素出来，然后放到NewTable中 for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 迁移源代码 正常ReHash过程就像代码中一样，新建一个新的table容量比oldtale要大，然后将oldtable中元素迁移到newtable中，在单线程下这样没什么问题。 并发下的Rehash假设有两个线程，当第一个线程执行到1Entry&lt;K, V&gt; next = e.next; 时候被挂起。1234假设有三个值， &lt;3,a&gt;,&lt;7,b&gt;,&lt;5,c&gt;,HashMap的初始大小是2 ______ e next|__0___| _______ _______ _______ |__1___| ---&gt; |_&lt;3,a&gt;_| -----&gt; |_&lt;7,b&gt;_| -----&gt; |_&lt;5,c&gt;_| 那么现在线程1如下：12345 ______ |__0___| |__1___| |__2___| |__3___| 那么线程2开始rehash：123456 ______ |__0___| _______|__1___| ----------&gt; |_&lt;5,c&gt;_| ---------&gt; null |__2___| _______ _______ |__3___| ---&gt; |_&lt;7,b&gt;_| -----&gt; |_&lt;3,a&gt;_| ----&gt; null next e 那么如果现在线程1被调度开始执行：12newTable[i] = e;e = next; 先是执行 newTalbe[i] = e; 然后是e = next，导致了e指向了key(7)， 而下一次循环的next = e.next导致了next指向了key(3)123456 ______ |__0___| _______|__1___| ----------&gt; |_&lt;5,c&gt;_| ---------&gt; null |__2___| _______ _______ |__3___| ---&gt; |_&lt;7,b&gt;_| -----&gt; |_&lt;3,a&gt;_| ----&gt; null e next 这样就会导致123456线程1 ______ |__0___| __________________ |__1___| | | |__2___| ___|___ ____|__ |__3___| ---&gt; |_&lt;3,a&gt;_| -----&gt; |_&lt;7,b&gt;_| ----&gt; null 产生循环链表，导致死循环。 concurrentHashMap原理concurrentHashMap采用锁分段技术：假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 HashEntry源码:12345static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; volatile关键字保证了多线程读取的时候一定是最新值。 ConcurrentHashMap包含一个Segment数组,每个Segment包含一个HashEntry数组,当修改HashEntry数组采用开链法处理冲突,所以它的每个HashEntry元素又是链表结构的元素。 基本操作源码分析构造方法:1234567891011121314151617181920212223242526272829public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; //1 int sshift = 0; int ssize = 1; while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; //2 &#125; this.segmentShift = 32 - sshift; //3 this.segmentMask = ssize - 1; //4 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);//5 Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; //6 UNSAFE.putOrderedObject(ss, SBASE, s0); this.segments = ss;&#125; 整个初始化是通过参数initialCapacity(初始容量)，loadFactor(增长因子)和concurrencyLevel(并发等级)来初始化segmentShift（段偏移量）、segmentMask（段掩码）和segment数组。 注释1: 最大的并发等级不能超过MAX_SEGMENTS 1&lt;&lt;16(也就是1的二进制向左移16位,65535) 注释2: 如果你传入的是15 就是向上取2的4次方倍 也就是16. 注释3和4: segmentShift和segmentMask在定位segment使用，segmentShift = 32 - ssize向左移位的次数，segmentMask = ssize - 1。ssize的最大长度是65536，对应的 segmentShift最大值为16，segmentMask最大值是65535，对应的二进制16位全为1； 注释5和6: 初始化segment 初始化每个segment的HashEntry长度； 创建segment数组和segment[0]。 HashEntry长度cap同样也是2的N次方，默认情况，ssize = 16，initialCapacity = 16，loadFactor = 0.75f，那么cap = 1，threshold = (int) cap * loadFactor = 0。 get操作1234567891011121314151617public V get(Object key) &#123; Segment&lt;K,V&gt; s; HashEntry&lt;K,V&gt;[] tab; int h = hash(key); //1 long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; //2 (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; 注释1: 根据key计算hash值 注释2: 根据计算出的hash值定位segment 如果segment不为null segment.table也不为null 跳转进里面的循环 里面的一大段东西 大致讲的就是通过hash值定位segment中对应的HashEntry 遍历HashEntry,如果key存在,返回key对应的value 如果不存在则返回null put操作1234567891011public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) s = ensureSegment(j); return s.put(key, hash, value, false);&#125; 判断值是否为null 计算hash值 定位segment 如果不存在，则创建 调用segment的put方法 还有一个putifAbsent的方法 ,唯一的不同就是最后的false变为了true再来看看Segment的put方法12345678910111213141516171819202122232425262728293031323334353637383940414243final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); //1 V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); //2 for (HashEntry&lt;K,V&gt; e = first;;) &#123; //3 if (e != null) &#123; K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 注释1: 获取锁 ，保证线程安全 注释2:定位到具体的HashEntry 注释3: 遍历HashEntry链表,如果key已存在 再判断传入的onlyIfAbsent的值 ,再决定是否覆盖旧值. 最后释放锁,返回旧值. 再说明一下put 和 putifAbsent的用法 这两个方法本身是线程安全的,但是要看你的用法是否恰当 例子:12345678910private static ConcurrentHashMap&lt;String,AtomicInteger&gt; map = new ConcurrentHashMap&lt;&gt;();public static void putInTo(String key) &#123; AtomicInteger obj = map.get(key); if(obj == null)&#123; map.put(key, new AtomicInteger(0)); &#125;else&#123; obj.incrementAndGet(); map.put(key, obj); &#125;&#125; 这段代码可以用最开始提供的测试代码进行测试，会发现如果多个线程调用putInTo方法 最后值会确定不了,每一次都是不一样。 就算是保证原子性的AtomicInteger 也会有误差,可能误差比较小罢了。这个误差的出现就会出现在前几次的操作。 原因: 多个线程同时进入putInTo 比如线程1已经把不存在的键值对存入,而线程2还没完成操作 再继续存入key相同的键值对,从而覆盖了前面存入的数据,导致数据丢失。 这段代码就能保证线程安全 而不用通过synchronized关键字来锁定方法12345678910111213private static ConcurrentMap&lt;String, AtomicLong&gt; wordCounts = newConcurrentHashMap&lt;&gt;(); public static long increase(String word) &#123; AtomicLong number = wordCounts.get(word); if(number == null) &#123; AtomicLong newNumber = newAtomicLong(0); number = wordCounts.putIfAbsent(word, newNumber); if(number == null) &#123; number = newNumber; &#125; &#125; return number.incrementAndGet(); &#125; 获取size12345678910111213141516171819202122232425262728293031323334353637public int size() &#123; final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; long sum; long last = 0L; int retries = -1; try &#123; for (;;) &#123; if (retries++ == RETRIES_BEFORE_LOCK) &#123; //1 for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; //2 int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; 注释1 : RETRIES_BEFORE_LOCK为不变常量2 尝试两次不锁住Segment的方式来统计每个Segment的大小,如果在统计的过程中Segment的count发生变化,这时候再加锁统计Segment的count]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解volatile]]></title>
      <url>%2F20170502%2Fjava%2F2_volatile%2F</url>
      <content type="text"><![CDATA[java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。 VolatileVolatile变量具有synchronized的可见性特性，但是不具备原子性。线程可以自动发现volatile变量的最新值，volatile可以用于线程安全，但是只能作用于很有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。 正确使用volatile变量的条件如果说要想使用volatile变量来替代锁，保证线程安全，必须满足一下两个条件： 该变量的写操作不依赖当前值 该变量没有包含在具有其他变量的不变式中 大多数的编程情况都于这两个条件其中之一冲突，所以计数器、互斥锁或任何具有多个变量相关的不定式不能单独用volatile解决。 使用volatile和不用volatile的一个例子jdk版本：jdk1.7.0_412345678910111213141516171819202122232425262728293031323334package com.fk.Thread;/** * Created by fengkai on 02/05/17. */public class VolatileTest &#123; private static boolean flag ; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for(;;) &#123; if (flag == !flag) &#123; System.out.println(&quot;end !&quot;); System.exit(1); &#125; &#125; &#125; &#125;).start(); Thread.sleep(1); new Thread(new Runnable() &#123; @Override public void run() &#123; for(;;) &#123; flag = !flag; &#125; &#125; &#125;).start(); &#125;&#125; 运行后程序会进入死循环，一直运行。 在当前的Java内存模型下，线程可以把变量保存在本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 12345678910111213141516171819202122232425262728293031323334package com.fk.Thread;/** * Created by fengkai on 02/05/17. */public class VolatileTest &#123; private static volatile boolean flag ; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for(;;) &#123; if (flag == !flag) &#123; System.out.println(&quot;end !&quot;); System.exit(1); &#125; &#125; &#125; &#125;).start(); Thread.sleep(1); new Thread(new Runnable() &#123; @Override public void run() &#123; for(;;) &#123; flag = !flag; &#125; &#125; &#125;).start(); &#125;&#125; 程序输出end，然后马上退出。 把该变量声明为volatile（不稳定的），这就指示JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。一般说来，多任务环境下各任务间共享的标志都应该加volatile修饰。 正确使用volatile的模式状态标志也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。 1234567891011volatile boolean shutdownRequested;...public void shutdown() &#123; shutdownRequested = true; &#125;public void doWork() &#123; while (!shutdownRequested) &#123; // do stuff &#125;&#125; 这样使用volatiile简化了编码。这种类型标记通常只有一个状态转换，然后程序停止。 用于一次安全的发布缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原语值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。（这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象）。实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型。下面一个示例，其中后台线程在启动阶段从数据库加载一些数据。其他代码在能够利用这些数据时，在使用之前将检查这些数据是否曾经发布过。12345678910111213141516171819public class BackgroundFloobleLoader &#123; public volatile Flooble theFlooble; public void initInBackground() &#123; // do lots of stuff theFlooble = new Flooble(); // this is the only write to theFlooble &#125;&#125;public class SomeOtherClass &#123; public void doWork() &#123; while (true) &#123; // do some stuff... // use the Flooble, but only if it is ready if (floobleLoader.theFlooble != null) doSomething(floobleLoader.theFlooble); &#125; &#125;&#125; 如果 theFlooble 引用不是 volatile 类型，doWork() 中的代码在解除对 theFlooble 的引用时，将会得到一个不完全构造的 Flooble。该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。 独立观察模式安全使用 volatile 的另一种简单模式是：定期 “发布” 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。使用该模式的另一种应用程序就是收集程序的统计信息。下面展示了身份验证机制如何记忆最近一次登录的用户的名字。将反复使用 lastUser 引用来发布值，以供程序的其他部分使用。 12345678910111213public class UserManager &#123; public volatile String lastUser; public boolean authenticate(String user, String password) &#123; boolean valid = passwordIsValid(user, password); if (valid) &#123; User u = new User(); activeUsers.add(u); lastUser = user; &#125; return valid; &#125;&#125; 该模式是前面模式的扩展；将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改。使用该值的代码需要清楚该值可能随时发生变化。 volatile bean 模式volatile bean 模式适用于将 JavaBeans 作为“荣誉结构”使用的框架。在 volatile bean 模式中，JavaBean 被用作一组具有 getter 和 setter 方法 的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。（这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义）。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。下面的示例展示了遵守 volatile bean 模式的 JavaBean：12345678910111213141516171819202122@ThreadSafepublic class Person &#123; private volatile String firstName; private volatile String lastName; private volatile int age; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getAge() &#123; return age; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 开销较低的读－写锁策略目前为止，了解了 volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。然而，如果读操作远远超过写操作，您可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。下面显示的线程安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。123456789101112@ThreadSafepublic class CheesyCounter &#123; // Employs the cheap read-write lock trick // All mutative operations MUST be done with the &apos;this&apos; lock held @GuardedBy(&quot;this&quot;) private volatile int value; public int getValue() &#123; return value; &#125; public synchronized int increment() &#123; return value++; &#125;&#125; 之所以将这种技术称之为 “开销较低的读－写锁” 是因为您使用了不同的同步机制进行读写操作。因为本例中的写操作违反了使用 volatile 的第一个条件，因此不能使用 volatile 安全地实现计数器 —— 您必须使用锁。然而，您可以在读操作中使用 volatile 确保当前值的可见性，因此可以使用锁进行所有变化的操作，使用 volatile 进行只读操作。其中，锁一次只允许一个线程访问值，volatile 允许多个线程执行读操作，因此当使用 volatile 保证读代码路径时，要比使用锁执行全部代码路径获得更高的共享度 —— 就像读－写操作一样。然而，要随时牢记这种模式的弱点：如果超越了该模式的最基本应用，结合这两个竞争的同步机制将变得非常困难。 性能考虑使用 volatile 变量的主要原因是其简易性：在某些情形下，使用 volatile 变量要比使用相应的锁简单得多。使用 volatile 变量次要原因是其性能：某些情况下，volatile 变量同步机制的性能要优于锁。很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 VM 也许能够完全删除锁机制，这使得我们难以抽象地比较 volatile 和 synchronized 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。volatile 操作不会像锁一样造成阻塞，因此，在能够安全使用 volatile 的情况下，volatile 可以提供一些优于锁的可伸缩特性。如果读操作的次数要远远超过写操作，与锁相比，volatile 变量通常能够减少同步的性能开销。 学习资料 ： Java 理论与实践: 正确使用 Volatile 变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo初步使用]]></title>
      <url>%2F20170417%2Fstart%2F</url>
      <content type="text"><![CDATA[HexoHexo是一个可以快速搭建博客的框架，使用Markdown解析文章，生成静态的网页。（可以部署在github上哦） hexo的安装hexo只依赖于 Node.js Git 上面的两个的安装就不说了，自行百度，hexo基于上述环境可以使用nmp安装 1npm install -g hexo-cli hexo的基本命令 hexo init [folder] #新建一个网站 hexo n [layout] #新建一篇文章 hexo g #生成静态文件 hexo d #部署网站。 hexo publish [layout] #发表草稿 hexo s #启动服务器 hexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public) hexo的配置配置内容来自官网 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md _layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 ###我的坑我吧整个hexo init初始化的项目放到github个人blog下……然后github就说解析不了博客了……然后想了想，我把master分支放hexo生成的public里面的东西，然后新建个分支放hexo的东西，这样就可以在哪里有环境就可以写，然后！！在编译器clone自己的项目，不能在同一个项目文件夹写完然后复制public的文件放到master分支，这样hexo的命令就用不了了，提示加载不到一个模块。最后吧一个项目clone两次，一个专门该mater分支，一个写…………坑了一上午]]></content>
    </entry>

    
  
  
</search>
