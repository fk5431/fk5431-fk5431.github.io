<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ConcurrentHashMap" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="ConcurrentHashMapjdk1.7ConcurrentHashMap 和 HashMap非常类似，ConcurrentHashMap在实现上采取了分段锁的思想来实现的。 ConcurrentHashMap在内部采用了一个叫做 Segment 的结构，一个Segment就类似HashMap中的table，这样在定位一个元素的时候，需要进行两次hash操作，一次定位到Segment，第二次">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="ConcurrentHashMap(1.7|1.8)阅读">
<meta property="og:url" content="http://yoursite.com/20191121/javasource/util/4_ConcurrentHashMap/index.html">
<meta property="og:site_name" content="fk5431">
<meta property="og:description" content="ConcurrentHashMapjdk1.7ConcurrentHashMap 和 HashMap非常类似，ConcurrentHashMap在实现上采取了分段锁的思想来实现的。 ConcurrentHashMap在内部采用了一个叫做 Segment 的结构，一个Segment就类似HashMap中的table，这样在定位一个元素的时候，需要进行两次hash操作，一次定位到Segment，第二次">
<meta property="og:image" content="http://yoursite.com/uploads/javasource/util/ConcurrentHashMap.png">
<meta property="og:updated_time" content="2019-11-30T14:38:01.726Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ConcurrentHashMap(1.7|1.8)阅读">
<meta name="twitter:description" content="ConcurrentHashMapjdk1.7ConcurrentHashMap 和 HashMap非常类似，ConcurrentHashMap在实现上采取了分段锁的思想来实现的。 ConcurrentHashMap在内部采用了一个叫做 Segment 的结构，一个Segment就类似HashMap中的table，这样在定位一个元素的时候，需要进行两次hash操作，一次定位到Segment，第二次">
<meta name="twitter:image" content="http://yoursite.com/uploads/javasource/util/ConcurrentHashMap.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/20191121/javasource/util/4_ConcurrentHashMap/"/>





  <title> ConcurrentHashMap(1.7|1.8)阅读 | fk5431 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d7bc2dc9efce9bfd4b23d39bce80284";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">fk5431</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">fk5431</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/20191121/javasource/util/4_ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fk">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="fk5431">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ConcurrentHashMap(1.7|1.8)阅读
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-21T22:20:28+08:00">
                2019-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          
             <span id="/20191121/javasource/util/4_ConcurrentHashMap/" class="leancloud_visitors" data-flag-title="ConcurrentHashMap(1.7|1.8)阅读">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h4><p>ConcurrentHashMap 和 HashMap非常类似，ConcurrentHashMap在实现上采取了分段锁的思想来实现的。</p>
<p>ConcurrentHashMap在内部采用了一个叫做 Segment 的结构，一个Segment就类似HashMap中的table，这样在定位一个元素的时候，需要进行两次hash操作，一次定位到Segment，第二次定位到Segment中的table的index。这样带来的好处的是写操作只需要针对对应的Segment的进行写，因此Segment的数量就是理论最大的并发数。</p>
<p>ConcurrentHashMap的结构类似如下： </p>
<p><img src="../../../../uploads/javasource/util/ConcurrentHashMap.png" alt="结构图"></p>
<h5 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;</div><div class="line">    private static final long serialVersionUID = 2249069246763182397L;</div><div class="line">    //重试次数 单核 1 多核64</div><div class="line">    static final int MAX_SCAN_RETRIES =</div><div class="line">        Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1;</div><div class="line">    //Segment中的table</div><div class="line">    transient volatile HashEntry&lt;K,V&gt;[] table;</div><div class="line">    //元素的数量</div><div class="line">    transient int count;</div><div class="line">    //对table的大小造成影响的操作的数量</div><div class="line">    transient int modCount;</div><div class="line">    //阈值</div><div class="line">    transient int threshold;</div><div class="line">     //负载因子</div><div class="line">    final float loadFactor;</div><div class="line">    //构造函数</div><div class="line">    Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</div><div class="line">        this.loadFactor = lf;</div><div class="line">        this.threshold = threshold;</div><div class="line">        this.table = tab;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">        //获取锁（针对Segment），获取到node为null，否则调用scanAndLockForPut方法</div><div class="line">        HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">            scanAndLockForPut(key, hash, value);</div><div class="line">        V oldValue;</div><div class="line">        try &#123;</div><div class="line">            //Segment中的table</div><div class="line">            HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">            int index = (tab.length - 1) &amp; hash;</div><div class="line">            HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">            for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                //对应index上的链表节点不为空，看看是不是有相等的key，有相等的key就替换； </div><div class="line">                if (e != null) &#123;</div><div class="line">                    K k;</div><div class="line">                    if ((k = e.key) == key ||</div><div class="line">                        (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                        oldValue = e.value;</div><div class="line">                        if (!onlyIfAbsent) &#123;</div><div class="line">                            e.value = value;</div><div class="line">                            ++modCount;</div><div class="line">                        &#125;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    e = e.next;//遍历下一个</div><div class="line">                &#125;</div><div class="line">                else &#123; //链表节点为空</div><div class="line">                    if (node != null)</div><div class="line">                        node.setNext(first);//加到链表的头部</div><div class="line">                    else //node为空就得新建</div><div class="line">                        node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                    int c = count + 1;</div><div class="line">                    if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                        rehash(node); //需不需要rehash</div><div class="line">                    else</div><div class="line">                        setEntryAt(tab, index, node);//直接插入node到指定index位置</div><div class="line">                    ++modCount;</div><div class="line">                    count = c;</div><div class="line">                    oldValue = null;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            unlock();</div><div class="line">        &#125;</div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    private void rehash(HashEntry&lt;K,V&gt; node) &#123;</div><div class="line">        HashEntry&lt;K,V&gt;[] oldTable = table;//旧的table</div><div class="line">        int oldCapacity = oldTable.length;</div><div class="line">        int newCapacity = oldCapacity &lt;&lt; 1;</div><div class="line">        threshold = (int)(newCapacity * loadFactor);</div><div class="line">        HashEntry&lt;K,V&gt;[] newTable =</div><div class="line">            (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];//新的table</div><div class="line">        int sizeMask = newCapacity - 1;</div><div class="line">        for (int i = 0; i &lt; oldCapacity ; i++) &#123;//遍历旧的table</div><div class="line">            HashEntry&lt;K,V&gt; e = oldTable[i]; //每个table的第一个entry</div><div class="line">            if (e != null) &#123;</div><div class="line">                HashEntry&lt;K,V&gt; next = e.next;</div><div class="line">                int idx = e.hash &amp; sizeMask; //重新计算新的index</div><div class="line">                if (next == null)   //  Single node on list 只有一个元素</div><div class="line">                    newTable[idx] = e;//直接在新的table新index上赋值该节点</div><div class="line">                else &#123; // Reuse consecutive sequence at same slot</div><div class="line">                    HashEntry&lt;K,V&gt; lastRun = e;</div><div class="line">                    int lastIdx = idx;</div><div class="line">                    for (HashEntry&lt;K,V&gt; last = next;</div><div class="line">                         last != null;</div><div class="line">                         last = last.next) &#123;//遍历链表</div><div class="line">                        int k = last.hash &amp; sizeMask; //在新table的位置</div><div class="line">                        if (k != lastIdx) &#123;//头结点和头结点的next元素的节点发生了变化</div><div class="line">                            lastIdx = k;</div><div class="line">                            lastRun = last;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // 1. lastRun 和 lastIdx 没有发生变化,也就是整个链表的每个元素位置和一样,都没有发生变化</div><div class="line">                    // 2.    lastRun 和 lastIdx 发生了变化,记录变化位置和变化节点,然后把变化的这个节点设置到新table</div><div class="line">                    newTable[lastIdx] = lastRun;</div><div class="line">                    // Clone remaining nodes</div><div class="line">                    for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</div><div class="line">                        V v = p.value;</div><div class="line">                        int h = p.hash;</div><div class="line">                        int k = h &amp; sizeMask;</div><div class="line">                        HashEntry&lt;K,V&gt; n = newTable[k];</div><div class="line">                        newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 处理扩容时那个添加的节点</div><div class="line">        int nodeIndex = node.hash &amp; sizeMask; // add the new node</div><div class="line">        node.setNext(newTable[nodeIndex]);</div><div class="line">        newTable[nodeIndex] = node;</div><div class="line">        table = newTable;</div><div class="line">    &#125;</div><div class="line">    //自选获取锁</div><div class="line">    private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</div><div class="line">        HashEntry&lt;K,V&gt; first = entryForHash(this, hash);//获取头节点 </div><div class="line">        HashEntry&lt;K,V&gt; e = first;</div><div class="line">        HashEntry&lt;K,V&gt; node = null;</div><div class="line">        int retries = -1; // negative while locating node 是为了找到对应hash桶,遍历链表时找到就停止</div><div class="line">        while (!tryLock()) &#123; //自旋获取锁</div><div class="line">            HashEntry&lt;K,V&gt; f; // to recheck first below</div><div class="line">            if (retries &lt; 0) &#123;</div><div class="line">                if (e == null) &#123;//结束遍历节点</div><div class="line">                    if (node == null) // speculatively create node</div><div class="line">                        node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</div><div class="line">                    retries = 0;</div><div class="line">                &#125;</div><div class="line">                else if (key.equals(e.key))// 找到节点 停止遍历</div><div class="line">                    retries = 0;</div><div class="line">                else</div><div class="line">                    e = e.next;</div><div class="line">            &#125;</div><div class="line">            else if (++retries &gt; MAX_SCAN_RETRIES) &#123;// 达到自旋的最大次数</div><div class="line">                lock();//阻塞</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if ((retries &amp; 1) == 0 &amp;&amp;</div><div class="line">                     (f = entryForHash(this, hash)) != first) &#123;//// 头结点变化,需要重新遍历,说明有新的节点加入或者移除</div><div class="line">                e = first = f; // re-traverse if entry changed</div><div class="line">                retries = -1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return node;</div><div class="line">    &#125;</div><div class="line">    //自旋获取锁</div><div class="line">    private void scanAndLock(Object key, int hash) &#123;</div><div class="line">        // similar to but simpler than scanAndLockForPut</div><div class="line">        HashEntry&lt;K,V&gt; first = entryForHash(this, hash);</div><div class="line">        HashEntry&lt;K,V&gt; e = first;</div><div class="line">        int retries = -1;</div><div class="line">        while (!tryLock()) &#123;</div><div class="line">            HashEntry&lt;K,V&gt; f;</div><div class="line">            if (retries &lt; 0) &#123;</div><div class="line">                if (e == null || key.equals(e.key))</div><div class="line">                    retries = 0;</div><div class="line">                else</div><div class="line">                    e = e.next;</div><div class="line">            &#125;</div><div class="line">            else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</div><div class="line">                lock();</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            else if ((retries &amp; 1) == 0 &amp;&amp;</div><div class="line">                     (f = entryForHash(this, hash)) != first) &#123;</div><div class="line">                e = first = f;</div><div class="line">                retries = -1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Segment中主要的方法就是put添加元素，rehash 对table进行扩容，scanAndLockForPut，scanAndLock自旋获取锁。</p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static final int DEFAULT_INITIAL_CAPACITY = 16;</div><div class="line"></div><div class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</div><div class="line"></div><div class="line">static final int DEFAULT_CONCURRENCY_LEVEL = 16;</div><div class="line"></div><div class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</div><div class="line"></div><div class="line">static final int MIN_SEGMENT_TABLE_CAPACITY = 2;</div><div class="line"></div><div class="line">static final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservative</div><div class="line"></div><div class="line">static final int RETRIES_BEFORE_LOCK = 2;</div></pre></td></tr></table></figure>
<p>ConcurrentHashMap 主要的默认参数和HashMap差不多。</p>
<blockquote>
<p>DEFAULT_CONCURRENCY_LEVEL 是默认的并发数（Segment数组的数量） MIN_SEGMENT_TABLE_CAPACITY 每个Segment最小的容量 MAX_SEGMENTS 每个Segment最大的容量   RETRIES_BEFORE_LOCK默认的自旋次数</p>
</blockquote>
<h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    Segment&lt;K,V&gt; s;</div><div class="line">    if (value == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    int hash = hash(key);//对应key的hash值</div><div class="line">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;//获取对应hash值在segments数组的index</div><div class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</div><div class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</div><div class="line">        s = ensureSegment(j); //如果对应内存偏移量中没有，则创建ensureSegment</div><div class="line">    return s.put(key, hash, value, false);</div><div class="line">&#125;</div><div class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</div><div class="line">    final Segment&lt;K,V&gt;[] ss = this.segments;</div><div class="line">    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</div><div class="line">    Segment&lt;K,V&gt; seg;</div><div class="line">    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</div><div class="line">        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype  以初始化创建的第一个index下标的值为模板</div><div class="line">        int cap = proto.table.length;</div><div class="line">        float lf = proto.loadFactor;</div><div class="line">        int threshold = (int)(cap * lf);</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</div><div class="line">        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">            == null) &#123; // recheck 再次检查有没有其他线程已经创建了</div><div class="line">            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</div><div class="line">            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">                   == null) &#123;</div><div class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s)) // 通过cas自旋的方式来创建</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return seg;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConcurrentHashMap中value不能为null，否则会抛出空指针异常，然后获取到对应key的hash值对应的Segment。<br>如果对应的Segment不存在，则通过CAS的方式去创建Segment，这是不加锁方式下又可能保证线程安全的方法。</p>
<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead</div><div class="line">    HashEntry&lt;K,V&gt;[] tab;</div><div class="line">    int h = hash(key);//对应key的hash值</div><div class="line">    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;//获取对应hash值存储所在segments数组中内存偏移量</div><div class="line">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;</div><div class="line">        (tab = s.table) != null) &#123; //获取到对应Segment中的table</div><div class="line">        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">             e != null; e = e.next) &#123;</div><div class="line">            K k;</div><div class="line">            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                return e.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConcurrentHashMap 的get方法就是先获取到对应的Segment，在获取到Segment中的table对应的HashEntry的头节点，但是通过UNSAFE.getObjectVolatile 获取到的是内存中最新的数据，在遍历的过程中，有可能数据被其他线程修改，导致最终返回的数据可能是过时的数据，因此此方法是弱一致性的。</p>
<h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public int size() &#123;</div><div class="line">    final Segment&lt;K,V&gt;[] segments = this.segments;</div><div class="line">    int size;</div><div class="line">    boolean overflow; // 是否溢出</div><div class="line">    long sum;         // 存储本次循环过程中计算得到的modCount的值</div><div class="line">    long last = 0L;   // 存储上一次遍历过程中计算得到的modCount的和</div><div class="line">    int retries = -1; // first iteration isn&apos;t retry</div><div class="line">    try &#123;</div><div class="line">        //无限for循环，结束条件就是任意前后两次遍历过程中modcount值的和是一样的，说明第二次遍历没有做任何变化</div><div class="line">        for (;;) &#123;//</div><div class="line">            //</div><div class="line">            //为了防止由于有线程不断在更新map而导致每次遍历过程一直发现modCount和上一次不一样导致线程一直进行遍历验证前后两次modCoun,加了一个最多重复的次数限制,超过这个次数则直接强制对所有的segment进行加锁(会导致可以延迟创建的Segment在这个过程中被创建）</div><div class="line">            if (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                    ensureSegment(j).lock(); // force creation</div><div class="line">            &#125;</div><div class="line">            sum = 0L;</div><div class="line">            size = 0;</div><div class="line">            overflow = false;</div><div class="line">            for (int j = 0; j &lt; segments.length; ++j) &#123;</div><div class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                if (seg != null) &#123;</div><div class="line">                    sum += seg.modCount;</div><div class="line">                    int c = seg.count;</div><div class="line">                    if (c &lt; 0 || (size += c) &lt; 0)</div><div class="line">                        overflow = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (sum == last)</div><div class="line">                break;</div><div class="line">            last = sum;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        //由于只有在retries等于RETRIES_BEFORE_LOCK时才会执行强制加锁，并且由于是用的retries++，所以强制加锁完毕后，retries的值是一定会大于RETRIES_BEFORE_LOCK的，</div><div class="line">        if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">            for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                segmentAt(segments, j).unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return overflow ? Integer.MAX_VALUE : size;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h4><p>在jdk1.8中没有采用分段锁的方式保证在多线程下的安全，采用的是CAS+synchronized来保证在多线程的安全。<br>底层的数据存储也变成了数组+链表+红黑树的方式。</p>
<h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node 和HashMap中的Node结构大致类似，只不过value和next通过volatile进行了修饰，保证了内存的可见性。还增加了一个find方法，通过这个node遍历之后的全部node找对对应key的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">final int hash;</div><div class="line">final K key;</div><div class="line">volatile V val;</div><div class="line">volatile Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">Node&lt;K,V&gt; find(int h, Object k) &#123;</div><div class="line">    Node&lt;K,V&gt; e = this;</div><div class="line">    if (k != null) &#123;</div><div class="line">        do &#123;</div><div class="line">            K ek;</div><div class="line">            if (e.hash == h &amp;&amp;</div><div class="line">                ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</div><div class="line">                return e;</div><div class="line">        &#125; while ((e = e.next) != null);</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">    while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">        //如果sizeCtl &lt; 0 说明已经有其他线程进行了初始化，此时只需要将CPU的时间片让出即可</div><div class="line">        if ((sc = sizeCtl) &lt; 0)</div><div class="line">            Thread.yield(); // lost initialization race; just spin</div><div class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">            //进行初始化</div><div class="line">            try &#123;</div><div class="line">                if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; 2);//0.75*capacity</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化的操作会在第一次put操作的时候进行，初始化的时候会调整table的大小。</p>
<h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    return putVal(key, value, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">    //value不能为空</div><div class="line">    if (key == null || value == null) throw new NullPointerException();</div><div class="line">    int hash = spread(key.hashCode());//获取key的hash值 （(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;）</div><div class="line">    int binCount = 0;</div><div class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">        if (tab == null || (n = tab.length) == 0)//第一次put的时候对table进行初始化</div><div class="line">            tab = initTable();</div><div class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; //如果table对应的index上的Node为空 进行初始化</div><div class="line">            if (casTabAt(tab, i, null,</div><div class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                break;                   // no lock when adding to empty bin</div><div class="line">        &#125;</div><div class="line">        else if ((fh = f.hash) == MOVED)// 当前Map在扩容，先协助扩容，在更新值。</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        else &#123; //hash冲突</div><div class="line">            V oldVal = null;</div><div class="line">            synchronized (f) &#123;//通过synchronized 进行加锁</div><div class="line">                if (tabAt(tab, i) == f) &#123;//链表头结点</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        binCount = 1;</div><div class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            if (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;//如果key存在的情况</div><div class="line">                                oldVal = e.val;</div><div class="line">                                if (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            if ((e = e.next) == null) &#123;//节点不存在的情况，直接加在链表的尾部</div><div class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, null);</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    else if (f instanceof TreeBin) &#123; //如果节点是红黑树节点，插入到红黑树节点中</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = 2;</div><div class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != null) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            if (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (binCount != 0) &#123;</div><div class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)//如果链表长度大于等于8</div><div class="line">                    treeifyBin(tab, i); //转变为红黑树</div><div class="line">                if (oldVal != null)</div><div class="line">                    return oldVal;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addCount(1L, binCount);// 统计节点个数，检查是否需要resize</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.8的ConcurrentHashMap进行put操作的时候，如果第一次进行put会先初始化table数组，如果对应的bucket为空，通过CAS将node放入对应的bucket，如果当前Map正在进行扩容，则先协助扩容；最后对这个节点加锁，如果节点存在进行更新值，如果不存在加在链表的尾部，如果是红黑树节点插入红黑树，最后会判断如果链表长度超过8会将当前链表转换为红黑树。</p>
<h6 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer"></a>helpTransfer</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</div><div class="line">    Node&lt;K,V&gt;[] nextTab; int sc;</div><div class="line">    //tab不为空 &amp;&amp; f 属于ForwardingNode类型（Node的hash值为-1）</div><div class="line">    //如果nextTable为null,则表示迁移完成了</div><div class="line">    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</div><div class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</div><div class="line">        int rs = resizeStamp(tab.length);//要调整的大小</div><div class="line">        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class="line">               (sc = sizeCtl) &lt; 0) &#123;</div><div class="line">            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</div><div class="line">                break;</div><div class="line">            //每有一个线程来帮助迁移，sizeCtl就+1</div><div class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</div><div class="line">                transfer(tab, nextTab);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return nextTab;</div><div class="line">    &#125;</div><div class="line">    return table;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法是帮助Map进行扩容</p>
<h6 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">private final void addCount(long x, int check) &#123;</div><div class="line">    CounterCell[] as; long b, s;</div><div class="line">    //更新baseCount</div><div class="line">    if ((as = counterCells) != null ||</div><div class="line">        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</div><div class="line">        CounterCell a; long v; int m;</div><div class="line">        boolean uncontended = true;</div><div class="line">        if (as == null || (m = as.length - 1) &lt; 0 ||</div><div class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</div><div class="line">            !(uncontended =</div><div class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">            fullAddCount(x, uncontended);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (check &lt;= 1)</div><div class="line">            return;</div><div class="line">        s = sumCount();</div><div class="line">    &#125;</div><div class="line">    if (check &gt;= 0) &#123;//是不是需要检查</div><div class="line">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class="line">        //符合扩容条件，map.size 大于阈值 table不为空，链表长度超过8</div><div class="line">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</div><div class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">            int rs = resizeStamp(n);//根据长度得到一标识</div><div class="line">            if (sc &lt; 0) &#123;//正在扩容</div><div class="line">                // 如果 sc 的低 16 位不等于 标识符（校验异常 sizeCtl 变化了）</div><div class="line">                // 如果 sc == 标识符 + 1 （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</div><div class="line">                // 如果 sc == 标识符 + 65535（帮助线程数已经达到最大）</div><div class="line">                // 如果 nextTable == null（结束扩容了）</div><div class="line">                // 如果 transferIndex &lt;= 0 (转移状态变化了)</div><div class="line">                // 结束循环 </div><div class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class="line">                    transferIndex &lt;= 0)</div><div class="line">                    break;</div><div class="line">                // 如果可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容</div><div class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class="line">                    transfer(tab, nt);</div><div class="line">            &#125;</div><div class="line">            // 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2.</div><div class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</div><div class="line">                // 更新 sc 为负数后，开始扩容。</div><div class="line">                transfer(tab, null);</div><div class="line">            s = sumCount();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>addCount 方法主要进行了两个操作 1 更新baseCount 2 检查是不是需要扩容<br>主要说下 检查扩容的部分，首先如果满足扩容条件的话，如果sc是负数则代表正在扩容，此时如果 sizeCtl变化|扩容结束|帮助线程达到最大|等结束循环。如果可以帮助扩容的话就在增加一个线程帮助扩容；如果还没开始扩容就把sc设为负数开始扩容。</p>
<h6 id="transfer-扩容"><a href="#transfer-扩容" class="headerlink" title="transfer 扩容"></a>transfer 扩容</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div></pre></td><td class="code"><pre><div class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class="line">    int n = tab.length, stride;</div><div class="line">    //stride最小为16</div><div class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</div><div class="line">    if (nextTab == null) &#123;            // initiating</div><div class="line">        try &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];//扩容两倍</div><div class="line">            nextTab = nt;</div><div class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class="line">            sizeCtl = Integer.MAX_VALUE;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        nextTable = nextTab;</div><div class="line">        transferIndex = n;</div><div class="line">    &#125;</div><div class="line">    int nextn = nextTab.length;</div><div class="line">    //正在被迁移的node，ForwardingNode的hash 是MOVED，key value next 都是null，其中的nextTable指向新的tab</div><div class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">    boolean advance = true;//advance为true，可以继续迁移下一个节点，false则停止迁移</div><div class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</div><div class="line">    for (int i = 0, bound = 0;;) &#123; //i迁移位置的索引，bound迁移的边界</div><div class="line">        Node&lt;K,V&gt; f; int fh;</div><div class="line">        while (advance) &#123;</div><div class="line">            int nextIndex, nextBound;</div><div class="line">            if (--i &gt;= bound || finishing) //finishing 为true停止while循环</div><div class="line">                advance = false;</div><div class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;//transferIndex（上一次迁移的边界）赋值给nextInde，transferIndex小于等于0，说明原数组的所有位置的迁移都有相应的线程去处理了，该线程可以不用迁移了</div><div class="line">                i = -1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">            //将nextBound赋值给bound，nextBound = nextIndex - stride（上一个边界减去步长）</div><div class="line">            else if (U.compareAndSwapInt</div><div class="line">                     (this, TRANSFERINDEX, nextIndex,</div><div class="line">                      nextBound = (nextIndex &gt; stride ?</div><div class="line">                                   nextIndex - stride : 0))) &#123;</div><div class="line">                bound = nextBound;</div><div class="line">                i = nextIndex - 1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //i &lt; 0 所有迁移任务完成</div><div class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</div><div class="line">            int sc;</div><div class="line">             //所有迁移完成，将nextTable设为空，sizeCtl为新tab.length * 0.75</div><div class="line">            if (finishing) &#123;</div><div class="line">                nextTable = null;</div><div class="line">                table = nextTab;</div><div class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            //该线程完成迁移，sizeCtl - 1，对应之前helpTransfer()中+1</div><div class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class="line">                //不相等说明还有其他线程没完成迁移，该线程结束任务</div><div class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                    return;</div><div class="line">                finishing = advance = true;//如果相等，则说明说有线程都完成任务了，设置finish为true</div><div class="line">                i = n; // recheck before commit</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else if ((f = tabAt(tab, i)) == null)//如果旧tab[i]为null，则放入ForwardingNode</div><div class="line">            advance = casTabAt(tab, i, null, fwd);</div><div class="line">        else if ((fh = f.hash) == MOVED)//该节点为ForwardingNode，则说明已经被迁移过了，就可以开始迁移下一个节点了</div><div class="line">            advance = true; // already processed</div><div class="line">        else &#123;</div><div class="line">            synchronized (f) &#123;//迁移开始加锁</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    Node&lt;K,V&gt; ln, hn;</div><div class="line">                    if (fh &gt;= 0) &#123;//fh &gt;= 0,说明是链表结构</div><div class="line">                        int runBit = fh &amp; n;</div><div class="line">                        Node&lt;K,V&gt; lastRun = f;</div><div class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class="line">                            int b = p.hash &amp; n;</div><div class="line">                            if (b != runBit) &#123;</div><div class="line">                                runBit = b;</div><div class="line">                                lastRun = p;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (runBit == 0) &#123;</div><div class="line">                            ln = lastRun;</div><div class="line">                            hn = null;</div><div class="line">                        &#125;</div><div class="line">                        else &#123;</div><div class="line">                            hn = lastRun;</div><div class="line">                            ln = null;</div><div class="line">                        &#125;</div><div class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                            if ((ph &amp; n) == 0)</div><div class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                            else</div><div class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                        &#125;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;</div><div class="line">                    else if (f instanceof TreeBin) &#123; //红黑树结构</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</div><div class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</div><div class="line">                        int lc = 0, hc = 0;</div><div class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</div><div class="line">                            int h = e.hash;</div><div class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class="line">                                (h, e.key, e.val, null, null);</div><div class="line">                            if ((h &amp; n) == 0) &#123;</div><div class="line">                                if ((p.prev = loTail) == null)</div><div class="line">                                    lo = p;</div><div class="line">                                else</div><div class="line">                                    loTail.next = p;</div><div class="line">                                loTail = p;</div><div class="line">                                ++lc;</div><div class="line">                            &#125;</div><div class="line">                            else &#123;</div><div class="line">                                if ((p.prev = hiTail) == null)</div><div class="line">                                    hi = p;</div><div class="line">                                else</div><div class="line">                                    hiTail.next = p;</div><div class="line">                                hiTail = p;</div><div class="line">                                ++hc;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">1. 遍历整个table，当前节点为空，则采用CAS的方式在当前位置放入fwd</div><div class="line">2. 当前节点已经为fwd(with hash field “MOVED”)，则已经有有线程处理完了了，直接跳过 ，这里是控制并发扩容的核心</div><div class="line">3. 当前节点为链表节点或红黑树，重新计算链表节点的hash值，移动到nextTable相应的位置（构建了一个反序链表和顺序链表，分别放置在i和i+n的位置上）。移动完成后，用Unsafe.putObjectVolatile在tab的原位置赋为为fwd, 表示当前节点已经完成扩容。</div><div class="line"></div><div class="line">##### get</div></pre></td></tr></table></figure>
<p>public V get(Object key) {<br>    Node<k,v>[] tab; Node<k,v> e, p; int n, eh; K ek;<br>    int h = spread(key.hashCode());<br>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;<br>        (e = tabAt(tab, (n - 1) &amp; h)) != null) {<br>        if ((eh = e.hash) == h) {<br>            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))<br>                return e.val;<br>        }<br>        else if (eh &lt; 0)<br>            return (p = e.find(h, key)) != null ? p.val : null;<br>        while ((e = e.next) != null) {<br>            if (e.hash == h &amp;&amp;<br>                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))<br>                return e.val;<br>        }<br>    }<br>    return null;<br>}<br>```</k,v></k,v></p>
<p>读取元素的操作就很简单，获取到对应的hash值，如果 table为空或对应的头节点为空直接返回null，不然就找到对应的bucket找到对应的node返回。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/pay/weixin.png" alt="fk WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/pay/zhifubao.png" alt="fk Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/20191124/java/4_集合简介/" rel="next" title="java集合简述">
                <i class="fa fa-chevron-left"></i> java集合简述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/20191118/javasource/util/3_AbstractQueuedSynchronizer/" rel="prev" title="aqs源码">
                aqs源码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/author.jpg"
               alt="fk" />
          <p class="site-author-name" itemprop="name">fk</p>
           
              <p class="site-description motion-element" itemprop="description">咸鱼翻身</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fk5431" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/fk5431" target="_blank" title="csdn">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  csdn
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/narr" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">1.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk1-7"><span class="nav-number">1.1.</span> <span class="nav-text">jdk1.7</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Segment"><span class="nav-number">1.1.1.</span> <span class="nav-text">Segment</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员变量"><span class="nav-number">1.1.2.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#put"><span class="nav-number">1.1.3.</span> <span class="nav-text">put</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get"><span class="nav-number">1.1.4.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#size"><span class="nav-number">1.1.5.</span> <span class="nav-text">size</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk1-8"><span class="nav-number">1.2.</span> <span class="nav-text">jdk1.8</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Node"><span class="nav-number">1.2.1.</span> <span class="nav-text">Node</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConcurrentHashMap的初始化"><span class="nav-number">1.2.2.</span> <span class="nav-text">ConcurrentHashMap的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#put方法"><span class="nav-number">1.2.3.</span> <span class="nav-text">put方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#helpTransfer"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">helpTransfer</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#addCount"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">addCount</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#transfer-扩容"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">transfer 扩容</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>
 


  

    
      <script id="dsq-count-scr" src="https://来自.disqus.com/count.js" async></script>
    

    

  




	





  
    
    <div id="cloud-tie-wrapper" class="cloud-tie-wrapper" style="max-width:980px;margin:0 auto;"></div>
    <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
    <script>
      var cloudTieConfig = {
        url: document.location.href,
        sourceId: "",
        productKey: "2e6823c974bd443290e74f94b9dcbe67",
        target: "cloud-tie-wrapper"
      };
      var yunManualLoad = true;
      Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
    </script>

  










    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fk</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>




  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("4lafdIPASG7vEXiPQdkjmVpF-gzGzoHsz", "rchYd5mRO9350AxY9wX3PEaU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  <script type="text/javascript" src="/js/src/particle.js" count="66" zindex="-2" opacity="0.5" color="0,0,0"></script>
</body>
</html>
